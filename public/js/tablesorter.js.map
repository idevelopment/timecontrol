{"version":3,"sources":["jquery.tablesorter.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"tablesorter.js","sourcesContent":["(function(factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(['jquery'], factory);\n\t} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\t\tmodule.exports = factory(require('jquery'));\n\t} else {\n\t\tfactory(jQuery);\n\t}\n}(function($) {\n\n/*! TableSorter (FORK) v2.26.0 *//*\n* Client-side table sorting with ease!\n* @requires jQuery v1.2.6+\n*\n* Copyright (c) 2007 Christian Bach\n* fork maintained by Rob Garrison\n*\n* Examples and docs at: http://tablesorter.com\n* Dual licensed under the MIT and GPL licenses:\n* http://www.opensource.org/licenses/mit-license.php\n* http://www.gnu.org/licenses/gpl.html\n*\n* @type jQuery\n* @name tablesorter (FORK)\n* @cat Plugins/Tablesorter\n* @author Christian Bach - christian.bach@polyester.se\n* @contributor Rob Garrison - https://github.com/Mottie/tablesorter\n*/\n/*jshint browser:true, jquery:true, unused:false, expr: true */\n;( function( $ ) {\n\t'use strict';\n\tvar ts = $.tablesorter = {\n\n\t\tversion : '2.26.0',\n\n\t\tparsers : [],\n\t\twidgets : [],\n\t\tdefaults : {\n\n\t\t\t// *** appearance\n\t\t\ttheme            : 'default',  // adds tablesorter-{theme} to the table for styling\n\t\t\twidthFixed       : false,      // adds colgroup to fix widths of columns\n\t\t\tshowProcessing   : false,      // show an indeterminate timer icon in the header when the table is sorted or filtered.\n\n\t\t\theaderTemplate   : '{content}',// header layout template (HTML ok); {content} = innerHTML, {icon} = <i/> // class from cssIcon\n\t\t\tonRenderTemplate : null,       // function( index, template ){ return template; }, // template is a string\n\t\t\tonRenderHeader   : null,       // function( index ){}, // nothing to return\n\n\t\t\t// *** functionality\n\t\t\tcancelSelection  : true,       // prevent text selection in the header\n\t\t\ttabIndex         : true,       // add tabindex to header for keyboard accessibility\n\t\t\tdateFormat       : 'mmddyyyy', // other options: 'ddmmyyy' or 'yyyymmdd'\n\t\t\tsortMultiSortKey : 'shiftKey', // key used to select additional columns\n\t\t\tsortResetKey     : 'ctrlKey',  // key used to remove sorting on a column\n\t\t\tusNumberFormat   : true,       // false for German '1.234.567,89' or French '1 234 567,89'\n\t\t\tdelayInit        : false,      // if false, the parsed table contents will not update until the first sort\n\t\t\tserverSideSorting: false,      // if true, server-side sorting should be performed because client-side sorting will be disabled, but the ui and events will still be used.\n\t\t\tresort           : true,       // default setting to trigger a resort after an 'update', 'addRows', 'updateCell', etc has completed\n\n\t\t\t// *** sort options\n\t\t\theaders          : {},         // set sorter, string, empty, locked order, sortInitialOrder, filter, etc.\n\t\t\tignoreCase       : true,       // ignore case while sorting\n\t\t\tsortForce        : null,       // column(s) first sorted; always applied\n\t\t\tsortList         : [],         // Initial sort order; applied initially; updated when manually sorted\n\t\t\tsortAppend       : null,       // column(s) sorted last; always applied\n\t\t\tsortStable       : false,      // when sorting two rows with exactly the same content, the original sort order is maintained\n\n\t\t\tsortInitialOrder : 'asc',      // sort direction on first click\n\t\t\tsortLocaleCompare: false,      // replace equivalent character (accented characters)\n\t\t\tsortReset        : false,      // third click on the header will reset column to default - unsorted\n\t\t\tsortRestart      : false,      // restart sort to 'sortInitialOrder' when clicking on previously unsorted columns\n\n\t\t\temptyTo          : 'bottom',   // sort empty cell to bottom, top, none, zero, emptyMax, emptyMin\n\t\t\tstringTo         : 'max',      // sort strings in numerical column as max, min, top, bottom, zero\n\t\t\tduplicateSpan    : true,       // colspan cells in the tbody will have duplicated content in the cache for each spanned column\n\t\t\ttextExtraction   : 'basic',    // text extraction method/function - function( node, table, cellIndex ){}\n\t\t\ttextAttribute    : 'data-text',// data-attribute that contains alternate cell text (used in default textExtraction function)\n\t\t\ttextSorter       : null,       // choose overall or specific column sorter function( a, b, direction, table, columnIndex ) [alt: ts.sortText]\n\t\t\tnumberSorter     : null,       // choose overall numeric sorter function( a, b, direction, maxColumnValue )\n\n\t\t\t// *** widget options\n\t\t\twidgets: [],                   // method to add widgets, e.g. widgets: ['zebra']\n\t\t\twidgetOptions    : {\n\t\t\t\tzebra : [ 'even', 'odd' ]    // zebra widget alternating row class names\n\t\t\t},\n\t\t\tinitWidgets      : true,       // apply widgets on tablesorter initialization\n\t\t\twidgetClass      : 'widget-{name}', // table class name template to match to include a widget\n\n\t\t\t// *** callbacks\n\t\t\tinitialized      : null,       // function( table ){},\n\n\t\t\t// *** extra css class names\n\t\t\ttableClass       : '',\n\t\t\tcssAsc           : '',\n\t\t\tcssDesc          : '',\n\t\t\tcssNone          : '',\n\t\t\tcssHeader        : '',\n\t\t\tcssHeaderRow     : '',\n\t\t\tcssProcessing    : '', // processing icon applied to header during sort/filter\n\n\t\t\tcssChildRow      : 'tablesorter-childRow', // class name indiciating that a row is to be attached to the its parent\n\t\t\tcssInfoBlock     : 'tablesorter-infoOnly', // don't sort tbody with this class name (only one class name allowed here!)\n\t\t\tcssNoSort        : 'tablesorter-noSort',      // class name added to element inside header; clicking on it won't cause a sort\n\t\t\tcssIgnoreRow     : 'tablesorter-ignoreRow',   // header row to ignore; cells within this row will not be added to c.$headers\n\n\t\t\tcssIcon          : 'tablesorter-icon', // if this class does not exist, the {icon} will not be added from the headerTemplate\n\t\t\tcssIconNone      : '', // class name added to the icon when there is no column sort\n\t\t\tcssIconAsc       : '', // class name added to the icon when the column has an ascending sort\n\t\t\tcssIconDesc      : '', // class name added to the icon when the column has a descending sort\n\n\t\t\t// *** events\n\t\t\tpointerClick     : 'click',\n\t\t\tpointerDown      : 'mousedown',\n\t\t\tpointerUp        : 'mouseup',\n\n\t\t\t// *** selectors\n\t\t\tselectorHeaders  : '> thead th, > thead td',\n\t\t\tselectorSort     : 'th, td',   // jQuery selector of content within selectorHeaders that is clickable to trigger a sort\n\t\t\tselectorRemove   : '.remove-me',\n\n\t\t\t// *** advanced\n\t\t\tdebug            : false,\n\n\t\t\t// *** Internal variables\n\t\t\theaderList: [],\n\t\t\tempties: {},\n\t\t\tstrings: {},\n\t\t\tparsers: []\n\n\t\t\t// removed: widgetZebra: { css: ['even', 'odd'] }\n\n\t\t},\n\n\t\t// internal css classes - these will ALWAYS be added to\n\t\t// the table and MUST only contain one class name - fixes #381\n\t\tcss : {\n\t\t\ttable      : 'tablesorter',\n\t\t\tcssHasChild: 'tablesorter-hasChildRow',\n\t\t\tchildRow   : 'tablesorter-childRow',\n\t\t\tcolgroup   : 'tablesorter-colgroup',\n\t\t\theader     : 'tablesorter-header',\n\t\t\theaderRow  : 'tablesorter-headerRow',\n\t\t\theaderIn   : 'tablesorter-header-inner',\n\t\t\ticon       : 'tablesorter-icon',\n\t\t\tprocessing : 'tablesorter-processing',\n\t\t\tsortAsc    : 'tablesorter-headerAsc',\n\t\t\tsortDesc   : 'tablesorter-headerDesc',\n\t\t\tsortNone   : 'tablesorter-headerUnSorted'\n\t\t},\n\n\t\t// labels applied to sortable headers for accessibility (aria) support\n\t\tlanguage : {\n\t\t\tsortAsc      : 'Ascending sort applied, ',\n\t\t\tsortDesc     : 'Descending sort applied, ',\n\t\t\tsortNone     : 'No sort applied, ',\n\t\t\tsortDisabled : 'sorting is disabled',\n\t\t\tnextAsc      : 'activate to apply an ascending sort',\n\t\t\tnextDesc     : 'activate to apply a descending sort',\n\t\t\tnextNone     : 'activate to remove the sort'\n\t\t},\n\n\t\tregex : {\n\t\t\ttemplateContent : /\\{content\\}/g,\n\t\t\ttemplateIcon    : /\\{icon\\}/g,\n\t\t\ttemplateName    : /\\{name\\}/i,\n\t\t\tspaces          : /\\s+/g,\n\t\t\tnonWord         : /\\W/g,\n\t\t\tformElements    : /(input|select|button|textarea)/i,\n\n\t\t\t// *** sort functions ***\n\t\t\t// regex used in natural sort\n\t\t\t// chunk/tokenize numbers & letters\n\t\t\tchunk  : /(^([+\\-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?$|^0x[0-9a-f]+$|\\d+)/gi,\n\t\t\t// replace chunks @ ends\n\t\t\tchunks : /(^\\\\0|\\\\0$)/,\n\t\t\thex    : /^0x[0-9a-f]+$/i,\n\n\t\t\t// *** formatFloat ***\n\t\t\tcomma                : /,/g,\n\t\t\tdigitNonUS           : /[\\s|\\.]/g,\n\t\t\tdigitNegativeTest    : /^\\s*\\([.\\d]+\\)/,\n\t\t\tdigitNegativeReplace : /^\\s*\\(([.\\d]+)\\)/,\n\n\t\t\t// *** isDigit ***\n\t\t\tdigitTest    : /^[\\-+(]?\\d+[)]?$/,\n\t\t\tdigitReplace : /[,.'\"\\s]/g\n\n\t\t},\n\n\t\t// digit sort, text location\n\t\tstring : {\n\t\t\tmax      : 1,\n\t\t\tmin      : -1,\n\t\t\temptymin : 1,\n\t\t\temptymax : -1,\n\t\t\tzero     : 0,\n\t\t\tnone     : 0,\n\t\t\t'null'   : 0,\n\t\t\ttop      : true,\n\t\t\tbottom   : false\n\t\t},\n\n\t\tkeyCodes : {\n\t\t\tenter : 13\n\t\t},\n\n\t\t// placeholder date parser data (globalize)\n\t\tdates : {},\n\n\t\t// These methods can be applied on table.config instance\n\t\tinstanceMethods : {},\n\n\t\t/*\n\t\t▄█████ ██████ ██████ ██  ██ █████▄\n\t\t▀█▄    ██▄▄     ██   ██  ██ ██▄▄██\n\t\t   ▀█▄ ██▀▀     ██   ██  ██ ██▀▀▀\n\t\t█████▀ ██████   ██   ▀████▀ ██\n\t\t*/\n\n\t\tsetup : function( table, c ) {\n\t\t\t// if no thead or tbody, or tablesorter is already present, quit\n\t\t\tif ( !table || !table.tHead || table.tBodies.length === 0 || table.hasInitialized === true ) {\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tif ( table.hasInitialized ) {\n\t\t\t\t\t\tconsole.warn( 'Stopping initialization. Tablesorter has already been initialized' );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error( 'Stopping initialization! No table, thead or tbody', table );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tmp = '',\n\t\t\t\t$table = $( table ),\n\t\t\t\tmeta = $.metadata;\n\t\t\t// initialization flag\n\t\t\ttable.hasInitialized = false;\n\t\t\t// table is being processed flag\n\t\t\ttable.isProcessing = true;\n\t\t\t// make sure to store the config object\n\t\t\ttable.config = c;\n\t\t\t// save the settings where they read\n\t\t\t$.data( table, 'tablesorter', c );\n\t\t\tif ( c.debug ) {\n\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Initializing tablesorter' );\n\t\t\t\t$.data( table, 'startoveralltimer', new Date() );\n\t\t\t}\n\n\t\t\t// removing this in version 3 (only supports jQuery 1.7+)\n\t\t\tc.supportsDataObject = ( function( version ) {\n\t\t\t\tversion[ 0 ] = parseInt( version[ 0 ], 10 );\n\t\t\t\treturn ( version[ 0 ] > 1 ) || ( version[ 0 ] === 1 && parseInt( version[ 1 ], 10 ) >= 4 );\n\t\t\t})( $.fn.jquery.split( '.' ) );\n\t\t\t// ensure case insensitivity\n\t\t\tc.emptyTo = c.emptyTo.toLowerCase();\n\t\t\tc.stringTo = c.stringTo.toLowerCase();\n\t\t\tc.last = { sortList : [], clickedIndex : -1 };\n\t\t\t// add table theme class only if there isn't already one there\n\t\t\tif ( !/tablesorter\\-/.test( $table.attr( 'class' ) ) ) {\n\t\t\t\ttmp = ( c.theme !== '' ? ' tablesorter-' + c.theme : '' );\n\t\t\t}\n\t\t\tc.table = table;\n\t\t\tc.$table = $table\n\t\t\t\t.addClass( ts.css.table + ' ' + c.tableClass + tmp )\n\t\t\t\t.attr( 'role', 'grid' );\n\t\t\tc.$headers = $table.find( c.selectorHeaders );\n\n\t\t\t// give the table a unique id, which will be used in namespace binding\n\t\t\tif ( !c.namespace ) {\n\t\t\t\tc.namespace = '.tablesorter' + Math.random().toString( 16 ).slice( 2 );\n\t\t\t} else {\n\t\t\t\t// make sure namespace starts with a period & doesn't have weird characters\n\t\t\t\tc.namespace = '.' + c.namespace.replace( ts.regex.nonWord, '' );\n\t\t\t}\n\n\t\t\tc.$table.children().children( 'tr' ).attr( 'role', 'row' );\n\t\t\tc.$tbodies = $table.children( 'tbody:not(.' + c.cssInfoBlock + ')' ).attr({\n\t\t\t\t'aria-live' : 'polite',\n\t\t\t\t'aria-relevant' : 'all'\n\t\t\t});\n\t\t\tif ( c.$table.children( 'caption' ).length ) {\n\t\t\t\ttmp = c.$table.children( 'caption' )[ 0 ];\n\t\t\t\tif ( !tmp.id ) { tmp.id = c.namespace.slice( 1 ) + 'caption'; }\n\t\t\t\tc.$table.attr( 'aria-labelledby', tmp.id );\n\t\t\t}\n\t\t\tc.widgetInit = {}; // keep a list of initialized widgets\n\t\t\t// change textExtraction via data-attribute\n\t\t\tc.textExtraction = c.$table.attr( 'data-text-extraction' ) || c.textExtraction || 'basic';\n\t\t\t// build headers\n\t\t\tts.buildHeaders( c );\n\t\t\t// fixate columns if the users supplies the fixedWidth option\n\t\t\t// do this after theme has been applied\n\t\t\tts.fixColumnWidth( table );\n\t\t\t// add widgets from class name\n\t\t\tts.addWidgetFromClass( table );\n\t\t\t// add widget options before parsing (e.g. grouping widget has parser settings)\n\t\t\tts.applyWidgetOptions( table );\n\t\t\t// try to auto detect column type, and store in tables config\n\t\t\tts.setupParsers( c );\n\t\t\t// start total row count at zero\n\t\t\tc.totalRows = 0;\n\t\t\t// build the cache for the tbody cells\n\t\t\t// delayInit will delay building the cache until the user starts a sort\n\t\t\tif ( !c.delayInit ) { ts.buildCache( c ); }\n\t\t\t// bind all header events and methods\n\t\t\tts.bindEvents( table, c.$headers, true );\n\t\t\tts.bindMethods( c );\n\t\t\t// get sort list from jQuery data or metadata\n\t\t\t// in jQuery < 1.4, an error occurs when calling $table.data()\n\t\t\tif ( c.supportsDataObject && typeof $table.data().sortlist !== 'undefined' ) {\n\t\t\t\tc.sortList = $table.data().sortlist;\n\t\t\t} else if ( meta && ( $table.metadata() && $table.metadata().sortlist ) ) {\n\t\t\t\tc.sortList = $table.metadata().sortlist;\n\t\t\t}\n\t\t\t// apply widget init code\n\t\t\tts.applyWidget( table, true );\n\t\t\t// if user has supplied a sort list to constructor\n\t\t\tif ( c.sortList.length > 0 ) {\n\t\t\t\tts.sortOn( c, c.sortList, {}, !c.initWidgets );\n\t\t\t} else {\n\t\t\t\tts.setHeadersCss( c );\n\t\t\t\tif ( c.initWidgets ) {\n\t\t\t\t\t// apply widget format\n\t\t\t\t\tts.applyWidget( table, false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// show processesing icon\n\t\t\tif ( c.showProcessing ) {\n\t\t\t\t$table\n\t\t\t\t.unbind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace )\n\t\t\t\t.bind( 'sortBegin' + c.namespace + ' sortEnd' + c.namespace, function( e ) {\n\t\t\t\t\tclearTimeout( c.timerProcessing );\n\t\t\t\t\tts.isProcessing( table );\n\t\t\t\t\tif ( e.type === 'sortBegin' ) {\n\t\t\t\t\t\tc.timerProcessing = setTimeout( function() {\n\t\t\t\t\t\t\tts.isProcessing( table, true );\n\t\t\t\t\t\t}, 500 );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// initialized\n\t\t\ttable.hasInitialized = true;\n\t\t\ttable.isProcessing = false;\n\t\t\tif ( c.debug ) {\n\t\t\t\tconsole.log( 'Overall initialization time: ' + ts.benchmark( $.data( table, 'startoveralltimer' ) ) );\n\t\t\t\tif ( c.debug && console.groupEnd ) { console.groupEnd(); }\n\t\t\t}\n\t\t\t$table.triggerHandler( 'tablesorter-initialized', table );\n\t\t\tif ( typeof c.initialized === 'function' ) {\n\t\t\t\tc.initialized( table );\n\t\t\t}\n\t\t},\n\n\t\tbindMethods : function( c ) {\n\t\t\tvar $table = c.$table,\n\t\t\t\tnamespace = c.namespace,\n\t\t\t\tevents = ( 'sortReset update updateRows updateAll updateHeaders addRows updateCell updateComplete ' +\n\t\t\t\t\t'sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup ' +\n\t\t\t\t\t'mouseleave ' ).split( ' ' )\n\t\t\t\t\t.join( namespace + ' ' );\n\t\t\t// apply easy methods that trigger bound events\n\t\t\t$table\n\t\t\t.unbind( events.replace( ts.regex.spaces, ' ' ) )\n\t\t\t.bind( 'sortReset' + namespace, function( e, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t// using this.config to ensure functions are getting a non-cached version of the config\n\t\t\t\tts.sortReset( this.config, callback );\n\t\t\t})\n\t\t\t.bind( 'updateAll' + namespace, function( e, resort, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.updateAll( this.config, resort, callback );\n\t\t\t})\n\t\t\t.bind( 'update' + namespace + ' updateRows' + namespace, function( e, resort, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.update( this.config, resort, callback );\n\t\t\t})\n\t\t\t.bind( 'updateHeaders' + namespace, function( e, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.updateHeaders( this.config, callback );\n\t\t\t})\n\t\t\t.bind( 'updateCell' + namespace, function( e, cell, resort, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.updateCell( this.config, cell, resort, callback );\n\t\t\t})\n\t\t\t.bind( 'addRows' + namespace, function( e, $row, resort, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.addRows( this.config, $row, resort, callback );\n\t\t\t})\n\t\t\t.bind( 'updateComplete' + namespace, function() {\n\t\t\t\tthis.isUpdating = false;\n\t\t\t})\n\t\t\t.bind( 'sorton' + namespace, function( e, list, callback, init ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.sortOn( this.config, list, callback, init );\n\t\t\t})\n\t\t\t.bind( 'appendCache' + namespace, function( e, callback, init ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.appendCache( this.config, init );\n\t\t\t\tif ( $.isFunction( callback ) ) {\n\t\t\t\t\tcallback( this );\n\t\t\t\t}\n\t\t\t})\n\t\t\t// $tbodies variable is used by the tbody sorting widget\n\t\t\t.bind( 'updateCache' + namespace, function( e, callback, $tbodies ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.updateCache( this.config, callback, $tbodies );\n\t\t\t})\n\t\t\t.bind( 'applyWidgetId' + namespace, function( e, id ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.applyWidgetId( this, id );\n\t\t\t})\n\t\t\t.bind( 'applyWidgets' + namespace, function( e, init ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t// apply widgets\n\t\t\t\tts.applyWidget( this, init );\n\t\t\t})\n\t\t\t.bind( 'refreshWidgets' + namespace, function( e, all, dontapply ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.refreshWidgets( this, all, dontapply );\n\t\t\t})\n\t\t\t.bind( 'removeWidget' + namespace, function( e, name, refreshing ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.removeWidget( this, name, refreshing );\n\t\t\t})\n\t\t\t.bind( 'destroy' + namespace, function( e, removeClasses, callback ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\tts.destroy( this, removeClasses, callback );\n\t\t\t})\n\t\t\t.bind( 'resetToLoadState' + namespace, function( e ) {\n\t\t\t\te.stopPropagation();\n\t\t\t\t// remove all widgets\n\t\t\t\tts.removeWidget( this, true, false );\n\t\t\t\t// restore original settings; this clears out current settings, but does not clear\n\t\t\t\t// values saved to storage.\n\t\t\t\tc = $.extend( true, ts.defaults, c.originalSettings );\n\t\t\t\tthis.hasInitialized = false;\n\t\t\t\t// setup the entire table again\n\t\t\t\tts.setup( this, c );\n\t\t\t});\n\t\t},\n\n\t\tbindEvents : function( table, $headers, core ) {\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tvar tmp,\n\t\t\t\tc = table.config,\n\t\t\t\tnamespace = c.namespace,\n\t\t\t\tdownTarget = null;\n\t\t\tif ( core !== true ) {\n\t\t\t\t$headers.addClass( namespace.slice( 1 ) + '_extra_headers' );\n\t\t\t\ttmp = $.fn.closest ? $headers.closest( 'table' )[ 0 ] : $headers.parents( 'table' )[ 0 ];\n\t\t\t\tif ( tmp && tmp.nodeName === 'TABLE' && tmp !== table ) {\n\t\t\t\t\t$( tmp ).addClass( namespace.slice( 1 ) + '_extra_table' );\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = ( c.pointerDown + ' ' + c.pointerUp + ' ' + c.pointerClick + ' sort keyup ' )\n\t\t\t\t.replace( ts.regex.spaces, ' ' )\n\t\t\t\t.split( ' ' )\n\t\t\t\t.join( namespace + ' ' );\n\t\t\t// apply event handling to headers and/or additional headers (stickyheaders, scroller, etc)\n\t\t\t$headers\n\t\t\t// http://stackoverflow.com/questions/5312849/jquery-find-self;\n\t\t\t.find( c.selectorSort )\n\t\t\t.add( $headers.filter( c.selectorSort ) )\n\t\t\t.unbind( tmp )\n\t\t\t.bind( tmp, function( e, external ) {\n\t\t\t\tvar $cell, cell, temp,\n\t\t\t\t\t$target = $( e.target ),\n\t\t\t\t\t// wrap event type in spaces, so the match doesn't trigger on inner words\n\t\t\t\t\ttype = ' ' + e.type + ' ';\n\t\t\t\t// only recognize left clicks\n\t\t\t\tif ( ( ( e.which || e.button ) !== 1 && !type.match( ' ' + c.pointerClick + ' | sort | keyup ' ) ) ||\n\t\t\t\t\t// allow pressing enter\n\t\t\t\t\t( type === ' keyup ' && e.which !== ts.keyCodes.enter ) ||\n\t\t\t\t\t// allow triggering a click event (e.which is undefined) & ignore physical clicks\n\t\t\t\t\t( type.match( ' ' + c.pointerClick + ' ' ) && typeof e.which !== 'undefined' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// ignore mouseup if mousedown wasn't on the same target\n\t\t\t\tif ( type.match( ' ' + c.pointerUp + ' ' ) && downTarget !== e.target && external !== true ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// set target on mousedown\n\t\t\t\tif ( type.match( ' ' + c.pointerDown + ' ' ) ) {\n\t\t\t\t\tdownTarget = e.target;\n\t\t\t\t\t// preventDefault needed or jQuery v1.3.2 and older throws an\n\t\t\t\t\t// \"Uncaught TypeError: handler.apply is not a function\" error\n\t\t\t\t\ttemp = $target.jquery.split( '.' );\n\t\t\t\t\tif ( temp[ 0 ] === '1' && temp[ 1 ] < 4 ) { e.preventDefault(); }\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdownTarget = null;\n\t\t\t\t// prevent sort being triggered on form elements\n\t\t\t\tif ( ts.regex.formElements.test( e.target.nodeName ) ||\n\t\t\t\t\t// nosort class name, or elements within a nosort container\n\t\t\t\t\t$target.hasClass( c.cssNoSort ) || $target.parents( '.' + c.cssNoSort ).length > 0 ||\n\t\t\t\t\t// elements within a button\n\t\t\t\t\t$target.parents( 'button' ).length > 0 ) {\n\t\t\t\t\treturn !c.cancelSelection;\n\t\t\t\t}\n\t\t\t\tif ( c.delayInit && ts.isEmptyObject( c.cache ) ) {\n\t\t\t\t\tts.buildCache( c );\n\t\t\t\t}\n\t\t\t\t// jQuery v1.2.6 doesn't have closest()\n\t\t\t\t$cell = $.fn.closest ? $( this ).closest( 'th, td' ) :\n\t\t\t\t\t/TH|TD/.test( this.nodeName ) ? $( this ) : $( this ).parents( 'th, td' );\n\t\t\t\t// reference original table headers and find the same cell\n\t\t\t\t// don't use $headers or IE8 throws an error - see #987\n\t\t\t\ttemp = $headers.index( $cell );\n\t\t\t\tc.last.clickedIndex = ( temp < 0 ) ? $cell.attr( 'data-column' ) : temp;\n\t\t\t\t// use column index if $headers is undefined\n\t\t\t\tcell = c.$headers[ c.last.clickedIndex ];\n\t\t\t\tif ( cell && !cell.sortDisabled ) {\n\t\t\t\t\tts.initSort( c, cell, e );\n\t\t\t\t}\n\t\t\t});\n\t\t\tif ( c.cancelSelection ) {\n\t\t\t\t// cancel selection\n\t\t\t\t$headers\n\t\t\t\t\t.attr( 'unselectable', 'on' )\n\t\t\t\t\t.bind( 'selectstart', false )\n\t\t\t\t\t.css({\n\t\t\t\t\t\t'user-select' : 'none',\n\t\t\t\t\t\t'MozUserSelect' : 'none' // not needed for jQuery 1.8+\n\t\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tbuildHeaders : function( c ) {\n\t\t\tvar $temp, icon, timer, indx;\n\t\t\tc.headerList = [];\n\t\t\tc.headerContent = [];\n\t\t\tc.sortVars = [];\n\t\t\tif ( c.debug ) {\n\t\t\t\ttimer = new Date();\n\t\t\t}\n\t\t\t// children tr in tfoot - see issue #196 & #547\n\t\t\t// don't pass table.config to computeColumnIndex here - widgets (math) pass it to \"quickly\" index tbody cells\n\t\t\tc.columns = ts.computeColumnIndex( c.$table.children( 'thead, tfoot' ).children( 'tr' ) );\n\t\t\t// add icon if cssIcon option exists\n\t\t\ticon = c.cssIcon ?\n\t\t\t\t'<i class=\"' + ( c.cssIcon === ts.css.icon ? ts.css.icon : c.cssIcon + ' ' + ts.css.icon ) + '\"></i>' :\n\t\t\t\t'';\n\t\t\t// redefine c.$headers here in case of an updateAll that replaces or adds an entire header cell - see #683\n\t\t\tc.$headers = $( $.map( c.$table.find( c.selectorHeaders ), function( elem, index ) {\n\t\t\t\tvar configHeaders, header, column, template, tmp,\n\t\t\t\t\t$elem = $( elem );\n\t\t\t\t// ignore cell (don't add it to c.$headers) if row has ignoreRow class\n\t\t\t\tif ( $elem.parent().hasClass( c.cssIgnoreRow ) ) { return; }\n\t\t\t\t// make sure to get header cell & not column indexed cell\n\t\t\t\tconfigHeaders = ts.getColumnData( c.table, c.headers, index, true );\n\t\t\t\t// save original header content\n\t\t\t\tc.headerContent[ index ] = $elem.html();\n\t\t\t\t// if headerTemplate is empty, don't reformat the header cell\n\t\t\t\tif ( c.headerTemplate !== '' && !$elem.find( '.' + ts.css.headerIn ).length ) {\n\t\t\t\t\t// set up header template\n\t\t\t\t\ttemplate = c.headerTemplate\n\t\t\t\t\t\t.replace( ts.regex.templateContent, $elem.html() )\n\t\t\t\t\t\t.replace( ts.regex.templateIcon, $elem.find( '.' + ts.css.icon ).length ? '' : icon );\n\t\t\t\t\tif ( c.onRenderTemplate ) {\n\t\t\t\t\t\theader = c.onRenderTemplate.apply( $elem, [ index, template ] );\n\t\t\t\t\t\t// only change t if something is returned\n\t\t\t\t\t\tif ( header && typeof header === 'string' ) {\n\t\t\t\t\t\t\ttemplate = header;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$elem.html( '<div class=\"' + ts.css.headerIn + '\">' + template + '</div>' ); // faster than wrapInner\n\t\t\t\t}\n\t\t\t\tif ( c.onRenderHeader ) {\n\t\t\t\t\tc.onRenderHeader.apply( $elem, [ index, c, c.$table ] );\n\t\t\t\t}\n\t\t\t\tcolumn = parseInt( $elem.attr( 'data-column' ), 10 );\n\t\t\t\telem.column = column;\n\t\t\t\ttmp = ts.getData( $elem, configHeaders, 'sortInitialOrder' ) || c.sortInitialOrder;\n\t\t\t\t// this may get updated numerous times if there are multiple rows\n\t\t\t\tc.sortVars[ column ] = {\n\t\t\t\t\tcount : -1, // set to -1 because clicking on the header automatically adds one\n\t\t\t\t\torder: ts.getOrder( tmp ) ?\n\t\t\t\t\t\t[ 1, 0, 2 ] : // desc, asc, unsorted\n\t\t\t\t\t\t[ 0, 1, 2 ],  // asc, desc, unsorted\n\t\t\t\t\tlockedOrder : false\n\t\t\t\t};\n\t\t\t\ttmp = ts.getData( $elem, configHeaders, 'lockedOrder' ) || false;\n\t\t\t\tif ( typeof tmp !== 'undefined' && tmp !== false ) {\n\t\t\t\t\tc.sortVars[ column ].lockedOrder = true;\n\t\t\t\t\tc.sortVars[ column ].order = ts.getOrder( tmp ) ? [ 1, 1, 1 ] : [ 0, 0, 0 ];\n\t\t\t\t}\n\t\t\t\t// add cell to headerList\n\t\t\t\tc.headerList[ index ] = elem;\n\t\t\t\t// add to parent in case there are multiple rows\n\t\t\t\t$elem\n\t\t\t\t\t.addClass( ts.css.header + ' ' + c.cssHeader )\n\t\t\t\t\t.parent()\n\t\t\t\t\t.addClass( ts.css.headerRow + ' ' + c.cssHeaderRow )\n\t\t\t\t\t.attr( 'role', 'row' );\n\t\t\t\t// allow keyboard cursor to focus on element\n\t\t\t\tif ( c.tabIndex ) {\n\t\t\t\t\t$elem.attr( 'tabindex', 0 );\n\t\t\t\t}\n\t\t\t\treturn elem;\n\t\t\t}) );\n\t\t\t// cache headers per column\n\t\t\tc.$headerIndexed = [];\n\t\t\tfor ( indx = 0; indx < c.columns; indx++ ) {\n\t\t\t\t// colspan in header making a column undefined\n\t\t\t\tif ( ts.isEmptyObject( c.sortVars[ indx ] ) ) {\n\t\t\t\t\tc.sortVars[ indx ] = {};\n\t\t\t\t}\n\t\t\t\t$temp = c.$headers.filter( '[data-column=\"' + indx + '\"]' );\n\t\t\t\t// target sortable column cells, unless there are none, then use non-sortable cells\n\t\t\t\t// .last() added in jQuery 1.4; use .filter(':last') to maintain compatibility with jQuery v1.2.6\n\t\t\t\tc.$headerIndexed[ indx ] = $temp.length ?\n\t\t\t\t\t$temp.not( '.sorter-false' ).length ?\n\t\t\t\t\t\t$temp.not( '.sorter-false' ).filter( ':last' ) :\n\t\t\t\t\t\t$temp.filter( ':last' ) :\n\t\t\t\t\t$();\n\t\t\t}\n\t\t\tc.$table.find( c.selectorHeaders ).attr({\n\t\t\t\tscope: 'col',\n\t\t\t\trole : 'columnheader'\n\t\t\t});\n\t\t\t// enable/disable sorting\n\t\t\tts.updateHeader( c );\n\t\t\tif ( c.debug ) {\n\t\t\t\tconsole.log( 'Built headers:' + ts.benchmark( timer ) );\n\t\t\t\tconsole.log( c.$headers );\n\t\t\t}\n\t\t},\n\n\t\t// Use it to add a set of methods to table.config which will be available for all tables.\n\t\t// This should be done before table initialization\n\t\taddInstanceMethods : function( methods ) {\n\t\t\t$.extend( ts.instanceMethods, methods );\n\t\t},\n\n\t\t/*\n\t\t█████▄ ▄████▄ █████▄ ▄█████ ██████ █████▄ ▄█████\n\t\t██▄▄██ ██▄▄██ ██▄▄██ ▀█▄    ██▄▄   ██▄▄██ ▀█▄\n\t\t██▀▀▀  ██▀▀██ ██▀██     ▀█▄ ██▀▀   ██▀██     ▀█▄\n\t\t██     ██  ██ ██  ██ █████▀ ██████ ██  ██ █████▀\n\t\t*/\n\t\tsetupParsers : function( c, $tbodies ) {\n\t\t\tvar rows, list, span, max, colIndex, indx, header, configHeaders,\n\t\t\t\tnoParser, parser, extractor, time, tbody, len,\n\t\t\t\ttable = c.table,\n\t\t\t\ttbodyIndex = 0,\n\t\t\t\tdebug = {};\n\t\t\t// update table bodies in case we start with an empty table\n\t\t\tc.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );\n\t\t\ttbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies;\n\t\t\tlen = tbody.length;\n\t\t\tif ( len === 0 ) {\n\t\t\t\treturn c.debug ? console.warn( 'Warning: *Empty table!* Not building a parser cache' ) : '';\n\t\t\t} else if ( c.debug ) {\n\t\t\t\ttime = new Date();\n\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Detecting parsers for each column' );\n\t\t\t}\n\t\t\tlist = {\n\t\t\t\textractors: [],\n\t\t\t\tparsers: []\n\t\t\t};\n\t\t\twhile ( tbodyIndex < len ) {\n\t\t\t\trows = tbody[ tbodyIndex ].rows;\n\t\t\t\tif ( rows.length ) {\n\t\t\t\t\tcolIndex = 0;\n\t\t\t\t\tmax = c.columns;\n\t\t\t\t\tfor ( indx = 0; indx < max; indx++ ) {\n\t\t\t\t\t\theader = c.$headerIndexed[ colIndex ];\n\t\t\t\t\t\tif ( header && header.length ) {\n\t\t\t\t\t\t\t// get column indexed table cell\n\t\t\t\t\t\t\tconfigHeaders = ts.getColumnData( table, c.headers, colIndex );\n\t\t\t\t\t\t\t// get column parser/extractor\n\t\t\t\t\t\t\textractor = ts.getParserById( ts.getData( header, configHeaders, 'extractor' ) );\n\t\t\t\t\t\t\tparser = ts.getParserById( ts.getData( header, configHeaders, 'sorter' ) );\n\t\t\t\t\t\t\tnoParser = ts.getData( header, configHeaders, 'parser' ) === 'false';\n\t\t\t\t\t\t\t// empty cells behaviour - keeping emptyToBottom for backwards compatibility\n\t\t\t\t\t\t\tc.empties[colIndex] = (\n\t\t\t\t\t\t\t\tts.getData( header, configHeaders, 'empty' ) ||\n\t\t\t\t\t\t\t\tc.emptyTo || ( c.emptyToBottom ? 'bottom' : 'top' ) ).toLowerCase();\n\t\t\t\t\t\t\t// text strings behaviour in numerical sorts\n\t\t\t\t\t\t\tc.strings[colIndex] = (\n\t\t\t\t\t\t\t\tts.getData( header, configHeaders, 'string' ) ||\n\t\t\t\t\t\t\t\tc.stringTo ||\n\t\t\t\t\t\t\t\t'max' ).toLowerCase();\n\t\t\t\t\t\t\tif ( noParser ) {\n\t\t\t\t\t\t\t\tparser = ts.getParserById( 'no-parser' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !extractor ) {\n\t\t\t\t\t\t\t\t// For now, maybe detect someday\n\t\t\t\t\t\t\t\textractor = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( !parser ) {\n\t\t\t\t\t\t\t\tparser = ts.detectParserForColumn( c, rows, -1, colIndex );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( c.debug ) {\n\t\t\t\t\t\t\t\tdebug[ '(' + colIndex + ') ' + header.text() ] = {\n\t\t\t\t\t\t\t\t\tparser : parser.id,\n\t\t\t\t\t\t\t\t\textractor : extractor ? extractor.id : 'none',\n\t\t\t\t\t\t\t\t\tstring : c.strings[ colIndex ],\n\t\t\t\t\t\t\t\t\tempty  : c.empties[ colIndex ]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.parsers[ colIndex ] = parser;\n\t\t\t\t\t\t\tlist.extractors[ colIndex ] = extractor;\n\t\t\t\t\t\t\tspan = header[ 0 ].colSpan - 1;\n\t\t\t\t\t\t\tif ( span > 0 ) {\n\t\t\t\t\t\t\t\tcolIndex += span;\n\t\t\t\t\t\t\t\tmax += span;\n\t\t\t\t\t\t\t\twhile ( span + 1 > 0 ) {\n\t\t\t\t\t\t\t\t\t// set colspan columns to use the same parsers & extractors\n\t\t\t\t\t\t\t\t\tlist.parsers[ colIndex - span ] = parser;\n\t\t\t\t\t\t\t\t\tlist.extractors[ colIndex - span ] = extractor;\n\t\t\t\t\t\t\t\t\tspan--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttbodyIndex += ( list.parsers.length ) ? len : 1;\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tif ( !ts.isEmptyObject( debug ) ) {\n\t\t\t\t\tconsole[ console.table ? 'table' : 'log' ]( debug );\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn( '  No parsers detected!' );\n\t\t\t\t}\n\t\t\t\tconsole.log( 'Completed detecting parsers' + ts.benchmark( time ) );\n\t\t\t\tif ( console.groupEnd ) { console.groupEnd(); }\n\t\t\t}\n\t\t\tc.parsers = list.parsers;\n\t\t\tc.extractors = list.extractors;\n\t\t},\n\n\t\taddParser : function( parser ) {\n\t\t\tvar indx,\n\t\t\t\tlen = ts.parsers.length,\n\t\t\t\tadd = true;\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\tif ( ts.parsers[ indx ].id.toLowerCase() === parser.id.toLowerCase() ) {\n\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( add ) {\n\t\t\t\tts.parsers[ ts.parsers.length ] = parser;\n\t\t\t}\n\t\t},\n\n\t\tgetParserById : function( name ) {\n\t\t\t/*jshint eqeqeq:false */\n\t\t\tif ( name == 'false' ) { return false; }\n\t\t\tvar indx,\n\t\t\t\tlen = ts.parsers.length;\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\tif ( ts.parsers[ indx ].id.toLowerCase() === ( name.toString() ).toLowerCase() ) {\n\t\t\t\t\treturn ts.parsers[ indx ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\tdetectParserForColumn : function( c, rows, rowIndex, cellIndex ) {\n\t\t\tvar cur, $node, row,\n\t\t\t\tindx = ts.parsers.length,\n\t\t\t\tnode = false,\n\t\t\t\tnodeValue = '',\n\t\t\t\tkeepLooking = true;\n\t\t\twhile ( nodeValue === '' && keepLooking ) {\n\t\t\t\trowIndex++;\n\t\t\t\trow = rows[ rowIndex ];\n\t\t\t\t// stop looking after 50 empty rows\n\t\t\t\tif ( row && rowIndex < 50 ) {\n\t\t\t\t\tif ( row.className.indexOf( ts.cssIgnoreRow ) < 0 ) {\n\t\t\t\t\t\tnode = rows[ rowIndex ].cells[ cellIndex ];\n\t\t\t\t\t\tnodeValue = ts.getElementText( c, node, cellIndex );\n\t\t\t\t\t\t$node = $( node );\n\t\t\t\t\t\tif ( c.debug ) {\n\t\t\t\t\t\t\tconsole.log( 'Checking if value was empty on row ' + rowIndex + ', column: ' +\n\t\t\t\t\t\t\t\tcellIndex + ': \"' + nodeValue + '\"' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeepLooking = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( --indx >= 0 ) {\n\t\t\t\tcur = ts.parsers[ indx ];\n\t\t\t\t// ignore the default text parser because it will always be true\n\t\t\t\tif ( cur && cur.id !== 'text' && cur.is && cur.is( nodeValue, c.table, node, $node ) ) {\n\t\t\t\t\treturn cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// nothing found, return the generic parser (text)\n\t\t\treturn ts.getParserById( 'text' );\n\t\t},\n\n\t\tgetElementText : function( c, node, cellIndex ) {\n\t\t\tif ( !node ) { return ''; }\n\t\t\tvar tmp,\n\t\t\t\textract = c.textExtraction || '',\n\t\t\t\t// node could be a jquery object\n\t\t\t\t// http://jsperf.com/jquery-vs-instanceof-jquery/2\n\t\t\t\t$node = node.jquery ? node : $( node );\n\t\t\tif ( typeof extract === 'string' ) {\n\t\t\t\t// check data-attribute first when set to 'basic'; don't use node.innerText - it's really slow!\n\t\t\t\t// http://www.kellegous.com/j/2013/02/27/innertext-vs-textcontent/\n\t\t\t\tif ( extract === 'basic' && typeof ( tmp = $node.attr( c.textAttribute ) ) !== 'undefined' ) {\n\t\t\t\t\treturn $.trim( tmp );\n\t\t\t\t}\n\t\t\t\treturn $.trim( node.textContent || $node.text() );\n\t\t\t} else {\n\t\t\t\tif ( typeof extract === 'function' ) {\n\t\t\t\t\treturn $.trim( extract( $node[ 0 ], c.table, cellIndex ) );\n\t\t\t\t} else if ( typeof ( tmp = ts.getColumnData( c.table, extract, cellIndex ) ) === 'function' ) {\n\t\t\t\t\treturn $.trim( tmp( $node[ 0 ], c.table, cellIndex ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// fallback\n\t\t\treturn $.trim( $node[ 0 ].textContent || $node.text() );\n\t\t},\n\n\t\t// centralized function to extract/parse cell contents\n\t\tgetParsedText : function( c, cell, colIndex, txt ) {\n\t\t\tif ( typeof txt === 'undefined' ) {\n\t\t\t\ttxt = ts.getElementText( c, cell, colIndex );\n\t\t\t}\n\t\t\t// if no parser, make sure to return the txt\n\t\t\tvar val = '' + txt,\n\t\t\t\tparser = c.parsers[ colIndex ],\n\t\t\t\textractor = c.extractors[ colIndex ];\n\t\t\tif ( parser ) {\n\t\t\t\t// do extract before parsing, if there is one\n\t\t\t\tif ( extractor && typeof extractor.format === 'function' ) {\n\t\t\t\t\ttxt = extractor.format( txt, c.table, cell, colIndex );\n\t\t\t\t}\n\t\t\t\t// allow parsing if the string is empty, previously parsing would change it to zero,\n\t\t\t\t// in case the parser needs to extract data from the table cell attributes\n\t\t\t\tval = parser.id === 'no-parser' ? '' :\n\t\t\t\t\t// make sure txt is a string (extractor may have converted it)\n\t\t\t\t\tparser.format( '' + txt, c.table, cell, colIndex );\n\t\t\t\tif ( c.ignoreCase && typeof val === 'string' ) {\n\t\t\t\t\tval = val.toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\n\t\t/*\n\t\t▄████▄ ▄████▄ ▄████▄ ██  ██ ██████\n\t\t██  ▀▀ ██▄▄██ ██  ▀▀ ██▄▄██ ██▄▄\n\t\t██  ▄▄ ██▀▀██ ██  ▄▄ ██▀▀██ ██▀▀\n\t\t▀████▀ ██  ██ ▀████▀ ██  ██ ██████\n\t\t*/\n\t\tbuildCache : function( c, callback, $tbodies ) {\n\t\t\tvar cache, val, txt, rowIndex, colIndex, tbodyIndex, $tbody, $row,\n\t\t\t\tcols, $cells, cell, cacheTime, totalRows, rowData, prevRowData,\n\t\t\t\tcolMax, span, cacheIndex, hasParser, max, len, index,\n\t\t\t\ttable = c.table,\n\t\t\t\tparsers = c.parsers;\n\t\t\t// update tbody variable\n\t\t\tc.$tbodies = c.$table.children( 'tbody:not(.' + c.cssInfoBlock + ')' );\n\t\t\t$tbody = typeof $tbodies === 'undefined' ? c.$tbodies : $tbodies,\n\t\t\tc.cache = {};\n\t\t\tc.totalRows = 0;\n\t\t\t// if no parsers found, return - it's an empty table.\n\t\t\tif ( !parsers ) {\n\t\t\t\treturn c.debug ? console.warn( 'Warning: *Empty table!* Not building a cache' ) : '';\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tcacheTime = new Date();\n\t\t\t}\n\t\t\t// processing icon\n\t\t\tif ( c.showProcessing ) {\n\t\t\t\tts.isProcessing( table, true );\n\t\t\t}\n\t\t\tfor ( tbodyIndex = 0; tbodyIndex < $tbody.length; tbodyIndex++ ) {\n\t\t\t\tcolMax = []; // column max value per tbody\n\t\t\t\tcache = c.cache[ tbodyIndex ] = {\n\t\t\t\t\tnormalized: [] // array of normalized row data; last entry contains 'rowData' above\n\t\t\t\t\t// colMax: #   // added at the end\n\t\t\t\t};\n\n\t\t\t\ttotalRows = ( $tbody[ tbodyIndex ] && $tbody[ tbodyIndex ].rows.length ) || 0;\n\t\t\t\tfor ( rowIndex = 0; rowIndex < totalRows; ++rowIndex ) {\n\t\t\t\t\trowData = {\n\t\t\t\t\t\t// order: original row order #\n\t\t\t\t\t\t// $row : jQuery Object[]\n\t\t\t\t\t\tchild: [], // child row text (filter widget)\n\t\t\t\t\t\traw: []    // original row text\n\t\t\t\t\t};\n\t\t\t\t\t/** Add the table data to main data array */\n\t\t\t\t\t$row = $( $tbody[ tbodyIndex ].rows[ rowIndex ] );\n\t\t\t\t\tcols = [];\n\t\t\t\t\t// if this is a child row, add it to the last row's children and continue to the next row\n\t\t\t\t\t// ignore child row class, if it is the first row\n\t\t\t\t\tif ( $row.hasClass( c.cssChildRow ) && rowIndex !== 0 ) {\n\t\t\t\t\t\tlen = cache.normalized.length - 1;\n\t\t\t\t\t\tprevRowData = cache.normalized[ len ][ c.columns ];\n\t\t\t\t\t\tprevRowData.$row = prevRowData.$row.add( $row );\n\t\t\t\t\t\t// add 'hasChild' class name to parent row\n\t\t\t\t\t\tif ( !$row.prev().hasClass( c.cssChildRow ) ) {\n\t\t\t\t\t\t\t$row.prev().addClass( ts.css.cssHasChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// save child row content (un-parsed!)\n\t\t\t\t\t\t$cells = $row.children( 'th, td' );\n\t\t\t\t\t\tlen = prevRowData.child.length;\n\t\t\t\t\t\tprevRowData.child[ len ] = [];\n\t\t\t\t\t\t// child row content does not account for colspans/rowspans; so indexing may be off\n\t\t\t\t\t\tcacheIndex = 0;\n\t\t\t\t\t\tmax = c.columns;\n\t\t\t\t\t\tfor ( colIndex = 0; colIndex < max; colIndex++ ) {\n\t\t\t\t\t\t\tcell = $cells[ colIndex ];\n\t\t\t\t\t\t\tif ( cell ) {\n\t\t\t\t\t\t\t\tprevRowData.child[ len ][ colIndex ] = ts.getParsedText( c, cell, colIndex );\n\t\t\t\t\t\t\t\tspan = $cells[ colIndex ].colSpan - 1;\n\t\t\t\t\t\t\t\tif ( span > 0 ) {\n\t\t\t\t\t\t\t\t\tcacheIndex += span;\n\t\t\t\t\t\t\t\t\tmax += span;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// go to the next for loop\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trowData.$row = $row;\n\t\t\t\t\trowData.order = rowIndex; // add original row position to rowCache\n\t\t\t\t\tcacheIndex = 0;\n\t\t\t\t\tmax = c.columns;\n\t\t\t\t\tfor ( colIndex = 0; colIndex < max; ++colIndex ) {\n\t\t\t\t\t\tcell = $row[ 0 ].cells[ colIndex ];\n\t\t\t\t\t\tif ( cell && cacheIndex < c.columns ) {\n\t\t\t\t\t\t\thasParser = typeof parsers[ cacheIndex ] !== 'undefined';\n\t\t\t\t\t\t\tif ( !hasParser && c.debug ) {\n\t\t\t\t\t\t\t\tconsole.warn( 'No parser found for row: ' + rowIndex + ', column: ' + colIndex +\n\t\t\t\t\t\t\t\t\t'; cell containing: \"' + $(cell).text() + '\"; does it have a header?' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval = ts.getElementText( c, cell, cacheIndex );\n\t\t\t\t\t\t\trowData.raw[ cacheIndex ] = val; // save original row text\n\t\t\t\t\t\t\t// save raw column text even if there is no parser set\n\t\t\t\t\t\t\ttxt = ts.getParsedText( c, cell, cacheIndex, val );\n\t\t\t\t\t\t\tcols[ cacheIndex ] = txt;\n\t\t\t\t\t\t\tif ( hasParser && ( parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {\n\t\t\t\t\t\t\t\t// determine column max value (ignore sign)\n\t\t\t\t\t\t\t\tcolMax[ cacheIndex ] = Math.max( Math.abs( txt ) || 0, colMax[ cacheIndex ] || 0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// allow colSpan in tbody\n\t\t\t\t\t\t\tspan = cell.colSpan - 1;\n\t\t\t\t\t\t\tif ( span > 0 ) {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t\twhile ( index <= span ) {\n\t\t\t\t\t\t\t\t\t// duplicate text (or not) to spanned columns\n\t\t\t\t\t\t\t\t\t// instead of setting duplicate span to empty string, use textExtraction to try to get a value\n\t\t\t\t\t\t\t\t\t// see http://stackoverflow.com/q/36449711/145346\n\t\t\t\t\t\t\t\t\ttxt = c.duplicateSpan || index === 0 ?\n\t\t\t\t\t\t\t\t\t\tval :\n\t\t\t\t\t\t\t\t\t\ttypeof c.textExtraction !== 'string' ?\n\t\t\t\t\t\t\t\t\t\t\tts.getElementText( c, cell, cacheIndex + index ) || '' :\n\t\t\t\t\t\t\t\t\t\t\t'';\n\t\t\t\t\t\t\t\t\trowData.raw[ cacheIndex + index ] = txt;\n\t\t\t\t\t\t\t\t\tcols[ cacheIndex + index ] = txt;\n\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcacheIndex += span;\n\t\t\t\t\t\t\t\tmax += span;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcacheIndex++;\n\t\t\t\t\t}\n\t\t\t\t\t// ensure rowData is always in the same location (after the last column)\n\t\t\t\t\tcols[ c.columns ] = rowData;\n\t\t\t\t\tcache.normalized[ cache.normalized.length ] = cols;\n\t\t\t\t}\n\t\t\t\tcache.colMax = colMax;\n\t\t\t\t// total up rows, not including child rows\n\t\t\t\tc.totalRows += cache.normalized.length;\n\n\t\t\t}\n\t\t\tif ( c.showProcessing ) {\n\t\t\t\tts.isProcessing( table ); // remove processing icon\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tlen = Math.min( 5, c.cache[ 0 ].normalized.length );\n\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Building cache for ' + c.totalRows +\n\t\t\t\t\t' rows (showing ' + len + ' rows in log)' + ts.benchmark( cacheTime ) );\n\t\t\t\tval = {};\n\t\t\t\tfor ( colIndex = 0; colIndex < c.columns; colIndex++ ) {\n\t\t\t\t\tfor ( cacheIndex = 0; cacheIndex < len; cacheIndex++ ) {\n\t\t\t\t\t\tif ( !val[ 'row: ' + cacheIndex ] ) {\n\t\t\t\t\t\t\tval[ 'row: ' + cacheIndex ] = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval[ 'row: ' + cacheIndex ][ c.$headerIndexed[ colIndex ].text() ] =\n\t\t\t\t\t\t\tc.cache[ 0 ].normalized[ cacheIndex ][ colIndex ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole[ console.table ? 'table' : 'log' ]( val );\n\t\t\t\tif ( console.groupEnd ) { console.groupEnd(); }\n\t\t\t}\n\t\t\tif ( $.isFunction( callback ) ) {\n\t\t\t\tcallback( table );\n\t\t\t}\n\t\t},\n\n\t\tgetColumnText : function( table, column, callback, rowFilter ) {\n\t\t\ttable = $( table )[0];\n\t\t\tvar tbodyIndex, rowIndex, cache, row, tbodyLen, rowLen, raw, parsed, $cell, result,\n\t\t\t\thasCallback = typeof callback === 'function',\n\t\t\t\tallColumns = column === 'all',\n\t\t\t\tdata = { raw : [], parsed: [], $cell: [] },\n\t\t\t\tc = table.config;\n\t\t\tif ( ts.isEmptyObject( c ) ) {\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tconsole.warn( 'No cache found - aborting getColumnText function!' );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttbodyLen = c.$tbodies.length;\n\t\t\t\tfor ( tbodyIndex = 0; tbodyIndex < tbodyLen; tbodyIndex++ ) {\n\t\t\t\t\tcache = c.cache[ tbodyIndex ].normalized;\n\t\t\t\t\trowLen = cache.length;\n\t\t\t\t\tfor ( rowIndex = 0; rowIndex < rowLen; rowIndex++ ) {\n\t\t\t\t\t\trow = cache[ rowIndex ];\n\t\t\t\t\t\tif ( rowFilter && !row[ c.columns ].$row.is( rowFilter ) ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\tparsed = ( allColumns ) ? row.slice( 0, c.columns ) : row[ column ];\n\t\t\t\t\t\trow = row[ c.columns ];\n\t\t\t\t\t\traw = ( allColumns ) ? row.raw : row.raw[ column ];\n\t\t\t\t\t\t$cell = ( allColumns ) ? row.$row.children() : row.$row.children().eq( column );\n\t\t\t\t\t\tif ( hasCallback ) {\n\t\t\t\t\t\t\tresult = callback({\n\t\t\t\t\t\t\t\ttbodyIndex : tbodyIndex,\n\t\t\t\t\t\t\t\trowIndex : rowIndex,\n\t\t\t\t\t\t\t\tparsed : parsed,\n\t\t\t\t\t\t\t\traw : raw,\n\t\t\t\t\t\t\t\t$row : row.$row,\n\t\t\t\t\t\t\t\t$cell : $cell\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( result !== false ) {\n\t\t\t\t\t\t\tdata.parsed[ data.parsed.length ] = parsed;\n\t\t\t\t\t\t\tdata.raw[ data.raw.length ] = raw;\n\t\t\t\t\t\t\tdata.$cell[ data.$cell.length ] = $cell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// return everything\n\t\t\t\treturn data;\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t██  ██ █████▄ █████▄ ▄████▄ ██████ ██████\n\t\t██  ██ ██▄▄██ ██  ██ ██▄▄██   ██   ██▄▄\n\t\t██  ██ ██▀▀▀  ██  ██ ██▀▀██   ██   ██▀▀\n\t\t▀████▀ ██     █████▀ ██  ██   ██   ██████\n\t\t*/\n\t\tsetHeadersCss : function( c ) {\n\t\t\tvar $sorted, indx, column,\n\t\t\t\tlist = c.sortList,\n\t\t\t\tlen = list.length,\n\t\t\t\tnone = ts.css.sortNone + ' ' + c.cssNone,\n\t\t\t\tcss = [ ts.css.sortAsc + ' ' + c.cssAsc, ts.css.sortDesc + ' ' + c.cssDesc ],\n\t\t\t\tcssIcon = [ c.cssIconAsc, c.cssIconDesc, c.cssIconNone ],\n\t\t\t\taria = [ 'ascending', 'descending' ],\n\t\t\t\t// find the footer\n\t\t\t\t$headers = c.$table\n\t\t\t\t\t.find( 'tfoot tr' )\n\t\t\t\t\t.children( 'td, th' )\n\t\t\t\t\t.add( $( c.namespace + '_extra_headers' ) )\n\t\t\t\t\t.removeClass( css.join( ' ' ) );\n\t\t\t// remove all header information\n\t\t\tc.$headers\n\t\t\t\t.removeClass( css.join( ' ' ) )\n\t\t\t\t.addClass( none )\n\t\t\t\t.attr( 'aria-sort', 'none' )\n\t\t\t\t.find( '.' + ts.css.icon )\n\t\t\t\t.removeClass( cssIcon.join( ' ' ) )\n\t\t\t\t.addClass( cssIcon[ 2 ] );\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t// direction = 2 means reset!\n\t\t\t\tif ( list[ indx ][ 1 ] !== 2 ) {\n\t\t\t\t\t// multicolumn sorting updating - see #1005\n\t\t\t\t\t// .not(function(){}) needs jQuery 1.4\n\t\t\t\t\t// filter(function(i, el){}) <- el is undefined in jQuery v1.2.6\n\t\t\t\t\t$sorted = c.$headers.filter( function( i ) {\n\t\t\t\t\t\t// only include headers that are in the sortList (this includes colspans)\n\t\t\t\t\t\tvar include = true,\n\t\t\t\t\t\t\t$el = c.$headers.eq( i ),\n\t\t\t\t\t\t\tcol = parseInt( $el.attr( 'data-column' ), 10 ),\n\t\t\t\t\t\t\tend = col + c.$headers[ i ].colSpan;\n\t\t\t\t\t\tfor ( ; col < end; col++ ) {\n\t\t\t\t\t\t\tinclude = include ? include || ts.isValueInArray( col, c.sortList ) > -1 : false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn include;\n\t\t\t\t\t});\n\n\t\t\t\t\t// choose the :last in case there are nested columns\n\t\t\t\t\t$sorted = $sorted\n\t\t\t\t\t\t.not( '.sorter-false' )\n\t\t\t\t\t\t.filter( '[data-column=\"' + list[ indx ][ 0 ] + '\"]' + ( len === 1 ? ':last' : '' ) );\n\t\t\t\t\tif ( $sorted.length ) {\n\t\t\t\t\t\tfor ( column = 0; column < $sorted.length; column++ ) {\n\t\t\t\t\t\t\tif ( !$sorted[ column ].sortDisabled ) {\n\t\t\t\t\t\t\t\t$sorted\n\t\t\t\t\t\t\t\t\t.eq( column )\n\t\t\t\t\t\t\t\t\t.removeClass( none )\n\t\t\t\t\t\t\t\t\t.addClass( css[ list[ indx ][ 1 ] ] )\n\t\t\t\t\t\t\t\t\t.attr( 'aria-sort', aria[ list[ indx ][ 1 ] ] )\n\t\t\t\t\t\t\t\t\t.find( '.' + ts.css.icon )\n\t\t\t\t\t\t\t\t\t.removeClass( cssIcon[ 2 ] )\n\t\t\t\t\t\t\t\t\t.addClass( cssIcon[ list[ indx ][ 1 ] ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// add sorted class to footer & extra headers, if they exist\n\t\t\t\t\t\tif ( $headers.length ) {\n\t\t\t\t\t\t\t$headers\n\t\t\t\t\t\t\t\t.filter( '[data-column=\"' + list[ indx ][ 0 ] + '\"]' )\n\t\t\t\t\t\t\t\t.removeClass( none )\n\t\t\t\t\t\t\t\t.addClass( css[ list[ indx ][ 1 ] ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add verbose aria labels\n\t\t\tlen = c.$headers.length;\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\tts.setColumnAriaLabel( c, c.$headers.eq( indx ) );\n\t\t\t}\n\t\t},\n\n\t\t// nextSort (optional), lets you disable next sort text\n\t\tsetColumnAriaLabel : function( c, $header, nextSort ) {\n\t\t\tif ( $header.length ) {\n\t\t\t\tvar column = parseInt( $header.attr( 'data-column' ), 10 ),\n\t\t\t\t\ttmp = $header.hasClass( ts.css.sortAsc ) ?\n\t\t\t\t\t\t'sortAsc' :\n\t\t\t\t\t\t$header.hasClass( ts.css.sortDesc ) ? 'sortDesc' : 'sortNone',\n\t\t\t\t\ttxt = $.trim( $header.text() ) + ': ' + ts.language[ tmp ];\n\t\t\t\tif ( $header.hasClass( 'sorter-false' ) || nextSort === false ) {\n\t\t\t\t\ttxt += ts.language.sortDisabled;\n\t\t\t\t} else {\n\t\t\t\t\tnextSort = c.sortVars[ column ].order[ ( c.sortVars[ column ].count + 1 ) % ( c.sortReset ? 3 : 2 ) ];\n\t\t\t\t\t// if nextSort\n\t\t\t\t\ttxt += ts.language[ nextSort === 0 ? 'nextAsc' : nextSort === 1 ? 'nextDesc' : 'nextNone' ];\n\t\t\t\t}\n\t\t\t\t$header.attr( 'aria-label', txt );\n\t\t\t}\n\t\t},\n\n\t\tupdateHeader : function( c ) {\n\t\t\tvar index, isDisabled, $header, col,\n\t\t\t\ttable = c.table,\n\t\t\t\tlen = c.$headers.length;\n\t\t\tfor ( index = 0; index < len; index++ ) {\n\t\t\t\t$header = c.$headers.eq( index );\n\t\t\t\tcol = ts.getColumnData( table, c.headers, index, true );\n\t\t\t\t// add 'sorter-false' class if 'parser-false' is set\n\t\t\t\tisDisabled = ts.getData( $header, col, 'sorter' ) === 'false' || ts.getData( $header, col, 'parser' ) === 'false';\n\t\t\t\tts.setColumnSort( c, $header, isDisabled );\n\t\t\t}\n\t\t},\n\n\t\tsetColumnSort : function( c, $header, isDisabled ) {\n\t\t\tvar id = c.table.id;\n\t\t\t$header[ 0 ].sortDisabled = isDisabled;\n\t\t\t$header[ isDisabled ? 'addClass' : 'removeClass' ]( 'sorter-false' )\n\t\t\t\t.attr( 'aria-disabled', '' + isDisabled );\n\t\t\t// disable tab index on disabled cells\n\t\t\tif ( c.tabIndex ) {\n\t\t\t\tif ( isDisabled ) {\n\t\t\t\t\t$header.removeAttr( 'tabindex' );\n\t\t\t\t} else {\n\t\t\t\t\t$header.attr( 'tabindex', '0' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// aria-controls - requires table ID\n\t\t\tif ( id ) {\n\t\t\t\tif ( isDisabled ) {\n\t\t\t\t\t$header.removeAttr( 'aria-controls' );\n\t\t\t\t} else {\n\t\t\t\t\t$header.attr( 'aria-controls', id );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tupdateHeaderSortCount : function( c, list ) {\n\t\t\tvar col, dir, group, indx, primary, temp, val, order,\n\t\t\t\tsortList = list || c.sortList,\n\t\t\t\tlen = sortList.length;\n\t\t\tc.sortList = [];\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\tval = sortList[ indx ];\n\t\t\t\t// ensure all sortList values are numeric - fixes #127\n\t\t\t\tcol = parseInt( val[ 0 ], 10 );\n\t\t\t\t// prevents error if sorton array is wrong\n\t\t\t\tif ( col < c.columns ) {\n\n\t\t\t\t\t// set order if not already defined - due to colspan header without associated header cell\n\t\t\t\t\t// adding this check prevents a javascript error\n\t\t\t\t\tif ( !c.sortVars[ col ].order ) {\n\t\t\t\t\t\torder = c.sortVars[ col ].order = ts.getOrder( c.sortInitialOrder ) ? [ 1, 0, 2 ] : [ 0, 1, 2 ];\n\t\t\t\t\t\tc.sortVars[ col ].count = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\torder = c.sortVars[ col ].order;\n\t\t\t\t\tdir = ( '' + val[ 1 ] ).match( /^(1|d|s|o|n)/ );\n\t\t\t\t\tdir = dir ? dir[ 0 ] : '';\n\t\t\t\t\t// 0/(a)sc (default), 1/(d)esc, (s)ame, (o)pposite, (n)ext\n\t\t\t\t\tswitch ( dir ) {\n\t\t\t\t\t\tcase '1' : case 'd' : // descending\n\t\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 's' : // same direction (as primary column)\n\t\t\t\t\t\t\t// if primary sort is set to 's', make it ascending\n\t\t\t\t\t\t\tdir = primary || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'o' :\n\t\t\t\t\t\t\ttemp = order[ ( primary || 0 ) % ( c.sortReset ? 3 : 2 ) ];\n\t\t\t\t\t\t\t// opposite of primary column; but resets if primary resets\n\t\t\t\t\t\t\tdir = temp === 0 ? 1 : temp === 1 ? 0 : 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'n' :\n\t\t\t\t\t\t\tdir = order[ ( ++c.sortVars[ col ].count ) % ( c.sortReset ? 3 : 2 ) ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault : // ascending\n\t\t\t\t\t\t\tdir = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprimary = indx === 0 ? dir : primary;\n\t\t\t\t\tgroup = [ col, parseInt( dir, 10 ) || 0 ];\n\t\t\t\t\tc.sortList[ c.sortList.length ] = group;\n\t\t\t\t\tdir = $.inArray( group[ 1 ], order ); // fixes issue #167\n\t\t\t\t\tc.sortVars[ col ].count = dir >= 0 ? dir : group[ 1 ] % ( c.sortReset ? 3 : 2 );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tupdateAll : function( c, resort, callback ) {\n\t\t\tvar table = c.table;\n\t\t\ttable.isUpdating = true;\n\t\t\tts.refreshWidgets( table, true, true );\n\t\t\tts.buildHeaders( c );\n\t\t\tts.bindEvents( table, c.$headers, true );\n\t\t\tts.bindMethods( c );\n\t\t\tts.commonUpdate( c, resort, callback );\n\t\t},\n\n\t\tupdate : function( c, resort, callback ) {\n\t\t\tvar table = c.table;\n\t\t\ttable.isUpdating = true;\n\t\t\t// update sorting (if enabled/disabled)\n\t\t\tts.updateHeader( c );\n\t\t\tts.commonUpdate( c, resort, callback );\n\t\t},\n\n\t\t// simple header update - see #989\n\t\tupdateHeaders : function( c, callback ) {\n\t\t\tc.table.isUpdating = true;\n\t\t\tts.buildHeaders( c );\n\t\t\tts.bindEvents( c.table, c.$headers, true );\n\t\t\tts.resortComplete( c, callback );\n\t\t},\n\n\t\tupdateCell : function( c, cell, resort, callback ) {\n\t\t\tif ( ts.isEmptyObject( c.cache ) ) {\n\t\t\t\t// empty table, do an update instead - fixes #1099\n\t\t\t\tts.updateHeader( c );\n\t\t\t\tts.commonUpdate( c, resort, callback );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tc.table.isUpdating = true;\n\t\t\tc.$table.find( c.selectorRemove ).remove();\n\t\t\t// get position from the dom\n\t\t\tvar tmp, indx, row, icell, cache, len,\n\t\t\t\t$tbodies = c.$tbodies,\n\t\t\t\t$cell = $( cell ),\n\t\t\t\t// update cache - format: function( s, table, cell, cellIndex )\n\t\t\t\t// no closest in jQuery v1.2.6\n\t\t\t\ttbodyIndex = $tbodies\n\t\t\t\t\t.index( $.fn.closest ? $cell.closest( 'tbody' ) : $cell.parents( 'tbody' ).filter( ':first' ) ),\n\t\t\t\ttbcache = c.cache[ tbodyIndex ],\n\t\t\t\t$row = $.fn.closest ? $cell.closest( 'tr' ) : $cell.parents( 'tr' ).filter( ':first' );\n\t\t\tcell = $cell[ 0 ]; // in case cell is a jQuery object\n\t\t\t// tbody may not exist if update is initialized while tbody is removed for processing\n\t\t\tif ( $tbodies.length && tbodyIndex >= 0 ) {\n\t\t\t\trow = $tbodies.eq( tbodyIndex ).find( 'tr' ).index( $row );\n\t\t\t\tcache = tbcache.normalized[ row ];\n\t\t\t\tlen = $row[ 0 ].cells.length;\n\t\t\t\tif ( len !== c.columns ) {\n\t\t\t\t\t// colspan in here somewhere!\n\t\t\t\t\ticell = 0;\n\t\t\t\t\ttmp = false;\n\t\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\t\tif ( !tmp && $row[ 0 ].cells[ indx ] !== cell ) {\n\t\t\t\t\t\t\ticell += $row[ 0 ].cells[ indx ].colSpan;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ticell = $cell.index();\n\t\t\t\t}\n\t\t\t\ttmp = ts.getElementText( c, cell, icell ); // raw\n\t\t\t\tcache[ c.columns ].raw[ icell ] = tmp;\n\t\t\t\ttmp = ts.getParsedText( c, cell, icell, tmp );\n\t\t\t\tcache[ icell ] = tmp; // parsed\n\t\t\t\tcache[ c.columns ].$row = $row;\n\t\t\t\tif ( ( c.parsers[ icell ].type || '' ).toLowerCase() === 'numeric' ) {\n\t\t\t\t\t// update column max value (ignore sign)\n\t\t\t\t\ttbcache.colMax[ icell ] = Math.max( Math.abs( tmp ) || 0, tbcache.colMax[ icell ] || 0 );\n\t\t\t\t}\n\t\t\t\ttmp = resort !== 'undefined' ? resort : c.resort;\n\t\t\t\tif ( tmp !== false ) {\n\t\t\t\t\t// widgets will be reapplied\n\t\t\t\t\tts.checkResort( c, tmp, callback );\n\t\t\t\t} else {\n\t\t\t\t\t// don't reapply widgets is resort is false, just in case it causes\n\t\t\t\t\t// problems with element focus\n\t\t\t\t\tts.resortComplete( c, callback );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tconsole.error( 'updateCell aborted, tbody missing or not within the indicated table' );\n\t\t\t\t}\n\t\t\t\tc.table.isUpdating = false;\n\t\t\t}\n\t\t},\n\n\t\taddRows : function( c, $row, resort, callback ) {\n\t\t\tvar txt, val, tbodyIndex, rowIndex, rows, cellIndex, len, order,\n\t\t\t\tcacheIndex, rowData, cells, cell, span,\n\t\t\t\t// allow passing a row string if only one non-info tbody exists in the table\n\t\t\t\tvalid = typeof $row === 'string' && c.$tbodies.length === 1 && /<tr/.test( $row || '' ),\n\t\t\t\ttable = c.table;\n\t\t\tif ( valid ) {\n\t\t\t\t$row = $( $row );\n\t\t\t\tc.$tbodies.append( $row );\n\t\t\t} else if ( !$row ||\n\t\t\t\t// row is a jQuery object?\n\t\t\t\t!( $row instanceof jQuery ) ||\n\t\t\t\t// row contained in the table?\n\t\t\t\t( $.fn.closest ? $row.closest( 'table' )[ 0 ] : $row.parents( 'table' )[ 0 ] ) !== c.table ) {\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tconsole.error( 'addRows method requires (1) a jQuery selector reference to rows that have already ' +\n\t\t\t\t\t\t'been added to the table, or (2) row HTML string to be added to a table with only one tbody' );\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttable.isUpdating = true;\n\t\t\tif ( ts.isEmptyObject( c.cache ) ) {\n\t\t\t\t// empty table, do an update instead - fixes #450\n\t\t\t\tts.updateHeader( c );\n\t\t\t\tts.commonUpdate( c, resort, callback );\n\t\t\t} else {\n\t\t\t\trows = $row.filter( 'tr' ).attr( 'role', 'row' ).length;\n\t\t\t\ttbodyIndex = c.$tbodies.index( $row.parents( 'tbody' ).filter( ':first' ) );\n\t\t\t\t// fixes adding rows to an empty table - see issue #179\n\t\t\t\tif ( !( c.parsers && c.parsers.length ) ) {\n\t\t\t\t\tts.setupParsers( c );\n\t\t\t\t}\n\t\t\t\t// add each row\n\t\t\t\tfor ( rowIndex = 0; rowIndex < rows; rowIndex++ ) {\n\t\t\t\t\tcacheIndex = 0;\n\t\t\t\t\tlen = $row[ rowIndex ].cells.length;\n\t\t\t\t\torder = c.cache[ tbodyIndex ].normalized.length;\n\t\t\t\t\tcells = [];\n\t\t\t\t\trowData = {\n\t\t\t\t\t\tchild : [],\n\t\t\t\t\t\traw : [],\n\t\t\t\t\t\t$row : $row.eq( rowIndex ),\n\t\t\t\t\t\torder : order\n\t\t\t\t\t};\n\t\t\t\t\t// add each cell\n\t\t\t\t\tfor ( cellIndex = 0; cellIndex < len; cellIndex++ ) {\n\t\t\t\t\t\tcell = $row[ rowIndex ].cells[ cellIndex ];\n\t\t\t\t\t\ttxt = ts.getElementText( c, cell, cacheIndex );\n\t\t\t\t\t\trowData.raw[ cacheIndex ] = txt;\n\t\t\t\t\t\tval = ts.getParsedText( c, cell, cacheIndex, txt );\n\t\t\t\t\t\tcells[ cacheIndex ] = val;\n\t\t\t\t\t\tif ( ( c.parsers[ cacheIndex ].type || '' ).toLowerCase() === 'numeric' ) {\n\t\t\t\t\t\t\t// update column max value (ignore sign)\n\t\t\t\t\t\t\tc.cache[ tbodyIndex ].colMax[ cacheIndex ] =\n\t\t\t\t\t\t\t\tMath.max( Math.abs( val ) || 0, c.cache[ tbodyIndex ].colMax[ cacheIndex ] || 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tspan = cell.colSpan - 1;\n\t\t\t\t\t\tif ( span > 0 ) {\n\t\t\t\t\t\t\tcacheIndex += span;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcacheIndex++;\n\t\t\t\t\t}\n\t\t\t\t\t// add the row data to the end\n\t\t\t\t\tcells[ c.columns ] = rowData;\n\t\t\t\t\t// update cache\n\t\t\t\t\tc.cache[ tbodyIndex ].normalized[ order ] = cells;\n\t\t\t\t}\n\t\t\t\t// resort using current settings\n\t\t\t\tts.checkResort( c, resort, callback );\n\t\t\t}\n\t\t},\n\n\t\tupdateCache : function( c, callback, $tbodies ) {\n\t\t\t// rebuild parsers\n\t\t\tif ( !( c.parsers && c.parsers.length ) ) {\n\t\t\t\tts.setupParsers( c, $tbodies );\n\t\t\t}\n\t\t\t// rebuild the cache map\n\t\t\tts.buildCache( c, callback, $tbodies );\n\t\t},\n\n\t\t// init flag (true) used by pager plugin to prevent widget application\n\t\t// renamed from appendToTable\n\t\tappendCache : function( c, init ) {\n\t\t\tvar parsed, totalRows, $tbody, $curTbody, rowIndex, tbodyIndex, appendTime,\n\t\t\t\ttable = c.table,\n\t\t\t\two = c.widgetOptions,\n\t\t\t\t$tbodies = c.$tbodies,\n\t\t\t\trows = [],\n\t\t\t\tcache = c.cache;\n\t\t\t// empty table - fixes #206/#346\n\t\t\tif ( ts.isEmptyObject( cache ) ) {\n\t\t\t\t// run pager appender in case the table was just emptied\n\t\t\t\treturn c.appender ? c.appender( table, rows ) :\n\t\t\t\t\ttable.isUpdating ? c.$table.triggerHandler( 'updateComplete', table ) : ''; // Fixes #532\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tappendTime = new Date();\n\t\t\t}\n\t\t\tfor ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {\n\t\t\t\t$tbody = $tbodies.eq( tbodyIndex );\n\t\t\t\tif ( $tbody.length ) {\n\t\t\t\t\t// detach tbody for manipulation\n\t\t\t\t\t$curTbody = ts.processTbody( table, $tbody, true );\n\t\t\t\t\tparsed = cache[ tbodyIndex ].normalized;\n\t\t\t\t\ttotalRows = parsed.length;\n\t\t\t\t\tfor ( rowIndex = 0; rowIndex < totalRows; rowIndex++ ) {\n\t\t\t\t\t\trows[rows.length] = parsed[ rowIndex ][ c.columns ].$row;\n\t\t\t\t\t\t// removeRows used by the pager plugin; don't render if using ajax - fixes #411\n\t\t\t\t\t\tif ( !c.appender || ( c.pager && ( !c.pager.removeRows || !wo.pager_removeRows ) && !c.pager.ajax ) ) {\n\t\t\t\t\t\t\t$curTbody.append( parsed[ rowIndex ][ c.columns ].$row );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// restore tbody\n\t\t\t\t\tts.processTbody( table, $curTbody, false );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( c.appender ) {\n\t\t\t\tc.appender( table, rows );\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tconsole.log( 'Rebuilt table' + ts.benchmark( appendTime ) );\n\t\t\t}\n\t\t\t// apply table widgets; but not before ajax completes\n\t\t\tif ( !init && !c.appender ) {\n\t\t\t\tts.applyWidget( table );\n\t\t\t}\n\t\t\tif ( table.isUpdating ) {\n\t\t\t\tc.$table.triggerHandler( 'updateComplete', table );\n\t\t\t}\n\t\t},\n\n\t\tcommonUpdate : function( c, resort, callback ) {\n\t\t\t// remove rows/elements before update\n\t\t\tc.$table.find( c.selectorRemove ).remove();\n\t\t\t// rebuild parsers\n\t\t\tts.setupParsers( c );\n\t\t\t// rebuild the cache map\n\t\t\tts.buildCache( c );\n\t\t\tts.checkResort( c, resort, callback );\n\t\t},\n\n\t\t/*\n\t\t▄█████ ▄████▄ █████▄ ██████ ██ █████▄ ▄████▄\n\t\t▀█▄    ██  ██ ██▄▄██   ██   ██ ██  ██ ██ ▄▄▄\n\t\t   ▀█▄ ██  ██ ██▀██    ██   ██ ██  ██ ██ ▀██\n\t\t█████▀ ▀████▀ ██  ██   ██   ██ ██  ██ ▀████▀\n\t\t*/\n\t\tinitSort : function( c, cell, event ) {\n\t\t\tif ( c.table.isUpdating ) {\n\t\t\t\t// let any updates complete before initializing a sort\n\t\t\t\treturn setTimeout( function(){\n\t\t\t\t\tts.initSort( c, cell, event );\n\t\t\t\t}, 50 );\n\t\t\t}\n\n\t\t\tvar arry, indx, headerIndx, dir, temp, tmp, $header,\n\t\t\t\tnotMultiSort = !event[ c.sortMultiSortKey ],\n\t\t\t\ttable = c.table,\n\t\t\t\tlen = c.$headers.length,\n\t\t\t\t// get current column index\n\t\t\t\tcol = parseInt( $( cell ).attr( 'data-column' ), 10 ),\n\t\t\t\torder = c.sortVars[ col ].order;\n\n\t\t\t// Only call sortStart if sorting is enabled\n\t\t\tc.$table.triggerHandler( 'sortStart', table );\n\t\t\t// get current column sort order\n\t\t\tc.sortVars[ col ].count =\n\t\t\t\tevent[ c.sortResetKey ] ? 2 : ( c.sortVars[ col ].count + 1 ) % ( c.sortReset ? 3 : 2 );\n\t\t\t// reset all sorts on non-current column - issue #30\n\t\t\tif ( c.sortRestart ) {\n\t\t\t\tfor ( headerIndx = 0; headerIndx < len; headerIndx++ ) {\n\t\t\t\t\t$header = c.$headers.eq( headerIndx );\n\t\t\t\t\ttmp = parseInt( $header.attr( 'data-column' ), 10 );\n\t\t\t\t\t// only reset counts on columns that weren't just clicked on and if not included in a multisort\n\t\t\t\t\tif ( col !== tmp && ( notMultiSort || $header.hasClass( ts.css.sortNone ) ) ) {\n\t\t\t\t\t\tc.sortVars[ tmp ].count = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// user only wants to sort on one column\n\t\t\tif ( notMultiSort ) {\n\t\t\t\t// flush the sort list\n\t\t\t\tc.sortList = [];\n\t\t\t\tc.last.sortList = [];\n\t\t\t\tif ( c.sortForce !== null ) {\n\t\t\t\t\tarry = c.sortForce;\n\t\t\t\t\tfor ( indx = 0; indx < arry.length; indx++ ) {\n\t\t\t\t\t\tif ( arry[ indx ][ 0 ] !== col ) {\n\t\t\t\t\t\t\tc.sortList[ c.sortList.length ] = arry[ indx ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add column to sort list\n\t\t\t\tdir = order[ c.sortVars[ col ].count ];\n\t\t\t\tif ( dir < 2 ) {\n\t\t\t\t\tc.sortList[ c.sortList.length ] = [ col, dir ];\n\t\t\t\t\t// add other columns if header spans across multiple\n\t\t\t\t\tif ( cell.colSpan > 1 ) {\n\t\t\t\t\t\tfor ( indx = 1; indx < cell.colSpan; indx++ ) {\n\t\t\t\t\t\t\tc.sortList[ c.sortList.length ] = [ col + indx, dir ];\n\t\t\t\t\t\t\t// update count on columns in colSpan\n\t\t\t\t\t\t\tc.sortVars[ col + indx ].count = $.inArray( dir, order );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// multi column sorting\n\t\t\t} else {\n\t\t\t\t// get rid of the sortAppend before adding more - fixes issue #115 & #523\n\t\t\t\tc.sortList = $.extend( [], c.last.sortList );\n\n\t\t\t\t// the user has clicked on an already sorted column\n\t\t\t\tif ( ts.isValueInArray( col, c.sortList ) >= 0 ) {\n\t\t\t\t\t// reverse the sorting direction\n\t\t\t\t\tfor ( indx = 0; indx < c.sortList.length; indx++ ) {\n\t\t\t\t\t\ttmp = c.sortList[ indx ];\n\t\t\t\t\t\tif ( tmp[ 0 ] === col ) {\n\t\t\t\t\t\t\t// order.count seems to be incorrect when compared to cell.count\n\t\t\t\t\t\t\ttmp[ 1 ] = order[ c.sortVars[ col ].count ];\n\t\t\t\t\t\t\tif ( tmp[1] === 2 ) {\n\t\t\t\t\t\t\t\tc.sortList.splice( indx, 1 );\n\t\t\t\t\t\t\t\tc.sortVars[ col ].count = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// add column to sort list array\n\t\t\t\t\tdir = order[ c.sortVars[ col ].count ];\n\t\t\t\t\tif ( dir < 2 ) {\n\t\t\t\t\t\tc.sortList[ c.sortList.length ] = [ col, dir ];\n\t\t\t\t\t\t// add other columns if header spans across multiple\n\t\t\t\t\t\tif ( cell.colSpan > 1 ) {\n\t\t\t\t\t\t\tfor ( indx = 1; indx < cell.colSpan; indx++ ) {\n\t\t\t\t\t\t\t\tc.sortList[ c.sortList.length ] = [ col + indx, dir ];\n\t\t\t\t\t\t\t\t// update count on columns in colSpan\n\t\t\t\t\t\t\t\tc.sortVars[ col + indx ].count = $.inArray( dir, order );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// save sort before applying sortAppend\n\t\t\tc.last.sortList = $.extend( [], c.sortList );\n\t\t\tif ( c.sortList.length && c.sortAppend ) {\n\t\t\t\tarry = $.isArray( c.sortAppend ) ? c.sortAppend : c.sortAppend[ c.sortList[ 0 ][ 0 ] ];\n\t\t\t\tif ( !ts.isEmptyObject( arry ) ) {\n\t\t\t\t\tfor ( indx = 0; indx < arry.length; indx++ ) {\n\t\t\t\t\t\tif ( arry[ indx ][ 0 ] !== col && ts.isValueInArray( arry[ indx ][ 0 ], c.sortList ) < 0 ) {\n\t\t\t\t\t\t\tdir = arry[ indx ][ 1 ];\n\t\t\t\t\t\t\ttemp = ( '' + dir ).match( /^(a|d|s|o|n)/ );\n\t\t\t\t\t\t\tif ( temp ) {\n\t\t\t\t\t\t\t\ttmp = c.sortList[ 0 ][ 1 ];\n\t\t\t\t\t\t\t\tswitch ( temp[ 0 ] ) {\n\t\t\t\t\t\t\t\t\tcase 'd' :\n\t\t\t\t\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 's' :\n\t\t\t\t\t\t\t\t\t\tdir = tmp;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'o' :\n\t\t\t\t\t\t\t\t\t\tdir = tmp === 0 ? 1 : 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'n' :\n\t\t\t\t\t\t\t\t\t\tdir = ( tmp + 1 ) % ( c.sortReset ? 3 : 2 );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tdir = 0;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc.sortList[ c.sortList.length ] = [ arry[ indx ][ 0 ], dir ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// sortBegin event triggered immediately before the sort\n\t\t\tc.$table.triggerHandler( 'sortBegin', table );\n\t\t\t// setTimeout needed so the processing icon shows up\n\t\t\tsetTimeout( function() {\n\t\t\t\t// set css for headers\n\t\t\t\tts.setHeadersCss( c );\n\t\t\t\tts.multisort( c );\n\t\t\t\tts.appendCache( c );\n\t\t\t\tc.$table.triggerHandler( 'sortBeforeEnd', table );\n\t\t\t\tc.$table.triggerHandler( 'sortEnd', table );\n\t\t\t}, 1 );\n\t\t},\n\n\t\t// sort multiple columns\n\t\tmultisort : function( c ) { /*jshint loopfunc:true */\n\t\t\tvar tbodyIndex, sortTime, colMax, rows,\n\t\t\t\ttable = c.table,\n\t\t\t\tdir = 0,\n\t\t\t\ttextSorter = c.textSorter || '',\n\t\t\t\tsortList = c.sortList,\n\t\t\t\tsortLen = sortList.length,\n\t\t\t\tlen = c.$tbodies.length;\n\t\t\tif ( c.serverSideSorting || ts.isEmptyObject( c.cache ) ) {\n\t\t\t\t// empty table - fixes #206/#346\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( c.debug ) { sortTime = new Date(); }\n\t\t\tfor ( tbodyIndex = 0; tbodyIndex < len; tbodyIndex++ ) {\n\t\t\t\tcolMax = c.cache[ tbodyIndex ].colMax;\n\t\t\t\trows = c.cache[ tbodyIndex ].normalized;\n\n\t\t\t\trows.sort( function( a, b ) {\n\t\t\t\t\tvar sortIndex, num, col, order, sort, x, y;\n\t\t\t\t\t// rows is undefined here in IE, so don't use it!\n\t\t\t\t\tfor ( sortIndex = 0; sortIndex < sortLen; sortIndex++ ) {\n\t\t\t\t\t\tcol = sortList[ sortIndex ][ 0 ];\n\t\t\t\t\t\torder = sortList[ sortIndex ][ 1 ];\n\t\t\t\t\t\t// sort direction, true = asc, false = desc\n\t\t\t\t\t\tdir = order === 0;\n\n\t\t\t\t\t\tif ( c.sortStable && a[ col ] === b[ col ] && sortLen === 1 ) {\n\t\t\t\t\t\t\treturn a[ c.columns ].order - b[ c.columns ].order;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// fallback to natural sort since it is more robust\n\t\t\t\t\t\tnum = /n/i.test( ts.getSortType( c.parsers, col ) );\n\t\t\t\t\t\tif ( num && c.strings[ col ] ) {\n\t\t\t\t\t\t\t// sort strings in numerical columns\n\t\t\t\t\t\t\tif ( typeof ( ts.string[ c.strings[ col ] ] ) === 'boolean' ) {\n\t\t\t\t\t\t\t\tnum = ( dir ? 1 : -1 ) * ( ts.string[ c.strings[ col ] ] ? -1 : 1 );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnum = ( c.strings[ col ] ) ? ts.string[ c.strings[ col ] ] || 0 : 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// fall back to built-in numeric sort\n\t\t\t\t\t\t\t// var sort = $.tablesorter['sort' + s]( a[col], b[col], dir, colMax[col], table );\n\t\t\t\t\t\t\tsort = c.numberSorter ? c.numberSorter( a[ col ], b[ col ], dir, colMax[ col ], table ) :\n\t\t\t\t\t\t\t\tts[ 'sortNumeric' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], num, colMax[ col ], col, c );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set a & b depending on sort direction\n\t\t\t\t\t\t\tx = dir ? a : b;\n\t\t\t\t\t\t\ty = dir ? b : a;\n\t\t\t\t\t\t\t// text sort function\n\t\t\t\t\t\t\tif ( typeof textSorter === 'function' ) {\n\t\t\t\t\t\t\t\t// custom OVERALL text sorter\n\t\t\t\t\t\t\t\tsort = textSorter( x[ col ], y[ col ], dir, col, table );\n\t\t\t\t\t\t\t} else if ( typeof textSorter === 'object' && textSorter.hasOwnProperty( col ) ) {\n\t\t\t\t\t\t\t\t// custom text sorter for a SPECIFIC COLUMN\n\t\t\t\t\t\t\t\tsort = textSorter[ col ]( x[ col ], y[ col ], dir, col, table );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// fall back to natural sort\n\t\t\t\t\t\t\t\tsort = ts[ 'sortNatural' + ( dir ? 'Asc' : 'Desc' ) ]( a[ col ], b[ col ], col, c );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( sort ) { return sort; }\n\t\t\t\t\t}\n\t\t\t\t\treturn a[ c.columns ].order - b[ c.columns ].order;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ( c.debug ) {\n\t\t\t\tconsole.log( 'Applying sort ' + sortList.toString() + ts.benchmark( sortTime ) );\n\t\t\t}\n\t\t},\n\n\t\tresortComplete : function( c, callback ) {\n\t\t\tif ( c.table.isUpdating ) {\n\t\t\t\tc.$table.triggerHandler( 'updateComplete', c.table );\n\t\t\t}\n\t\t\tif ( $.isFunction( callback ) ) {\n\t\t\t\tcallback( c.table );\n\t\t\t}\n\t\t},\n\n\t\tcheckResort : function( c, resort, callback ) {\n\t\t\tvar sortList = $.isArray( resort ) ? resort : c.sortList,\n\t\t\t\t// if no resort parameter is passed, fallback to config.resort (true by default)\n\t\t\t\tresrt = typeof resort === 'undefined' ? c.resort : resort;\n\t\t\t// don't try to resort if the table is still processing\n\t\t\t// this will catch spamming of the updateCell method\n\t\t\tif ( resrt !== false && !c.serverSideSorting && !c.table.isProcessing ) {\n\t\t\t\tif ( sortList.length ) {\n\t\t\t\t\tts.sortOn( c, sortList, function() {\n\t\t\t\t\t\tts.resortComplete( c, callback );\n\t\t\t\t\t}, true );\n\t\t\t\t} else {\n\t\t\t\t\tts.sortReset( c, function() {\n\t\t\t\t\t\tts.resortComplete( c, callback );\n\t\t\t\t\t\tts.applyWidget( c.table, false );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tts.resortComplete( c, callback );\n\t\t\t\tts.applyWidget( c.table, false );\n\t\t\t}\n\t\t},\n\n\t\tsortOn : function( c, list, callback, init ) {\n\t\t\tvar table = c.table;\n\t\t\tc.$table.triggerHandler( 'sortStart', table );\n\t\t\t// update header count index\n\t\t\tts.updateHeaderSortCount( c, list );\n\t\t\t// set css for headers\n\t\t\tts.setHeadersCss( c );\n\t\t\t// fixes #346\n\t\t\tif ( c.delayInit && ts.isEmptyObject( c.cache ) ) {\n\t\t\t\tts.buildCache( c );\n\t\t\t}\n\t\t\tc.$table.triggerHandler( 'sortBegin', table );\n\t\t\t// sort the table and append it to the dom\n\t\t\tts.multisort( c );\n\t\t\tts.appendCache( c, init );\n\t\t\tc.$table.triggerHandler( 'sortBeforeEnd', table );\n\t\t\tc.$table.triggerHandler( 'sortEnd', table );\n\t\t\tts.applyWidget( table );\n\t\t\tif ( $.isFunction( callback ) ) {\n\t\t\t\tcallback( table );\n\t\t\t}\n\t\t},\n\n\t\tsortReset : function( c, callback ) {\n\t\t\tc.sortList = [];\n\t\t\tts.setHeadersCss( c );\n\t\t\tts.multisort( c );\n\t\t\tts.appendCache( c );\n\t\t\tif ( $.isFunction( callback ) ) {\n\t\t\t\tcallback( c.table );\n\t\t\t}\n\t\t},\n\n\t\tgetSortType : function( parsers, column ) {\n\t\t\treturn ( parsers && parsers[ column ] ) ? parsers[ column ].type || '' : '';\n\t\t},\n\n\t\tgetOrder : function( val ) {\n\t\t\t// look for 'd' in 'desc' order; return true\n\t\t\treturn ( /^d/i.test( val ) || val === 1 );\n\t\t},\n\n\t\t// Natural sort - https://github.com/overset/javascript-natural-sort (date sorting removed)\n\t\t// this function will only accept strings, or you'll see 'TypeError: undefined is not a function'\n\t\t// I could add a = a.toString(); b = b.toString(); but it'll slow down the sort overall\n\t\tsortNatural : function( a, b ) {\n\t\t\tif ( a === b ) { return 0; }\n\t\t\tvar aNum, bNum, aFloat, bFloat, indx, max,\n\t\t\t\tregex = ts.regex;\n\t\t\t// first try and sort Hex codes\n\t\t\tif ( regex.hex.test( b ) ) {\n\t\t\t\taNum = parseInt( a.match( regex.hex ), 16 );\n\t\t\t\tbNum = parseInt( b.match( regex.hex ), 16 );\n\t\t\t\tif ( aNum < bNum ) { return -1; }\n\t\t\t\tif ( aNum > bNum ) { return 1; }\n\t\t\t}\n\t\t\t// chunk/tokenize\n\t\t\taNum = a.replace( regex.chunk, '\\\\0$1\\\\0' ).replace( regex.chunks, '' ).split( '\\\\0' );\n\t\t\tbNum = b.replace( regex.chunk, '\\\\0$1\\\\0' ).replace( regex.chunks, '' ).split( '\\\\0' );\n\t\t\tmax = Math.max( aNum.length, bNum.length );\n\t\t\t// natural sorting through split numeric strings and default strings\n\t\t\tfor ( indx = 0; indx < max; indx++ ) {\n\t\t\t\t// find floats not starting with '0', string or 0 if not defined\n\t\t\t\taFloat = isNaN( aNum[ indx ] ) ? aNum[ indx ] || 0 : parseFloat( aNum[ indx ] ) || 0;\n\t\t\t\tbFloat = isNaN( bNum[ indx ] ) ? bNum[ indx ] || 0 : parseFloat( bNum[ indx ] ) || 0;\n\t\t\t\t// handle numeric vs string comparison - number < string - (Kyle Adams)\n\t\t\t\tif ( isNaN( aFloat ) !== isNaN( bFloat ) ) { return isNaN( aFloat ) ? 1 : -1; }\n\t\t\t\t// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'\n\t\t\t\tif ( typeof aFloat !== typeof bFloat ) {\n\t\t\t\t\taFloat += '';\n\t\t\t\t\tbFloat += '';\n\t\t\t\t}\n\t\t\t\tif ( aFloat < bFloat ) { return -1; }\n\t\t\t\tif ( aFloat > bFloat ) { return 1; }\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tsortNaturalAsc : function( a, b, col, c ) {\n\t\t\tif ( a === b ) { return 0; }\n\t\t\tvar empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];\n\t\t\tif ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }\n\t\t\tif ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }\n\t\t\treturn ts.sortNatural( a, b );\n\t\t},\n\n\t\tsortNaturalDesc : function( a, b, col, c ) {\n\t\t\tif ( a === b ) { return 0; }\n\t\t\tvar empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];\n\t\t\tif ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }\n\t\t\tif ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }\n\t\t\treturn ts.sortNatural( b, a );\n\t\t},\n\n\t\t// basic alphabetical sort\n\t\tsortText : function( a, b ) {\n\t\t\treturn a > b ? 1 : ( a < b ? -1 : 0 );\n\t\t},\n\n\t\t// return text string value by adding up ascii value\n\t\t// so the text is somewhat sorted when using a digital sort\n\t\t// this is NOT an alphanumeric sort\n\t\tgetTextValue : function( val, num, max ) {\n\t\t\tif ( max ) {\n\t\t\t\t// make sure the text value is greater than the max numerical value (max)\n\t\t\t\tvar indx,\n\t\t\t\t\tlen = val ? val.length : 0,\n\t\t\t\t\tn = max + num;\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\tn += val.charCodeAt( indx );\n\t\t\t\t}\n\t\t\t\treturn num * n;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tsortNumericAsc : function( a, b, num, max, col, c ) {\n\t\t\tif ( a === b ) { return 0; }\n\t\t\tvar empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];\n\t\t\tif ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : -empty || -1; }\n\t\t\tif ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : empty || 1; }\n\t\t\tif ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }\n\t\t\tif ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }\n\t\t\treturn a - b;\n\t\t},\n\n\t\tsortNumericDesc : function( a, b, num, max, col, c ) {\n\t\t\tif ( a === b ) { return 0; }\n\t\t\tvar empty = ts.string[ ( c.empties[ col ] || c.emptyTo ) ];\n\t\t\tif ( a === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? -1 : 1 ) : empty || 1; }\n\t\t\tif ( b === '' && empty !== 0 ) { return typeof empty === 'boolean' ? ( empty ? 1 : -1 ) : -empty || -1; }\n\t\t\tif ( isNaN( a ) ) { a = ts.getTextValue( a, num, max ); }\n\t\t\tif ( isNaN( b ) ) { b = ts.getTextValue( b, num, max ); }\n\t\t\treturn b - a;\n\t\t},\n\n\t\tsortNumeric : function( a, b ) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\t/*\n\t\t██ ██ ██ ██ █████▄ ▄████▄ ██████ ██████ ▄█████\n\t\t██ ██ ██ ██ ██  ██ ██ ▄▄▄ ██▄▄     ██   ▀█▄\n\t\t██ ██ ██ ██ ██  ██ ██ ▀██ ██▀▀     ██      ▀█▄\n\t\t███████▀ ██ █████▀ ▀████▀ ██████   ██   █████▀\n\t\t*/\n\t\taddWidget : function( widget ) {\n\t\t\tif ( widget.id && !ts.isEmptyObject( ts.getWidgetById( widget.id ) ) ) {\n\t\t\t\tconsole.warn( '\"' + widget.id + '\" widget was loaded more than once!' );\n\t\t\t}\n\t\t\tts.widgets[ ts.widgets.length ] = widget;\n\t\t},\n\n\t\thasWidget : function( $table, name ) {\n\t\t\t$table = $( $table );\n\t\t\treturn $table.length && $table[ 0 ].config && $table[ 0 ].config.widgetInit[ name ] || false;\n\t\t},\n\n\t\tgetWidgetById : function( name ) {\n\t\t\tvar indx, widget,\n\t\t\t\tlen = ts.widgets.length;\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\twidget = ts.widgets[ indx ];\n\t\t\t\tif ( widget && widget.id && widget.id.toLowerCase() === name.toLowerCase() ) {\n\t\t\t\t\treturn widget;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tapplyWidgetOptions : function( table ) {\n\t\t\tvar indx, widget,\n\t\t\t\tc = table.config,\n\t\t\t\tlen = c.widgets.length;\n\t\t\tif ( len ) {\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\twidget = ts.getWidgetById( c.widgets[ indx ] );\n\t\t\t\t\tif ( widget && widget.options ) {\n\t\t\t\t\t\tc.widgetOptions = $.extend( true, {}, widget.options, c.widgetOptions );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\taddWidgetFromClass : function( table ) {\n\t\t\tvar len, indx,\n\t\t\t\tc = table.config,\n\t\t\t\t// look for widgets to apply from table class\n\t\t\t\t// don't match from 'ui-widget-content'; use \\S instead of \\w to include widgets\n\t\t\t\t// with dashes in the name, e.g. \"widget-test-2\" extracts out \"test-2\"\n\t\t\t\tregex = '^' + c.widgetClass.replace( ts.regex.templateName, '(\\\\S+)+' ) + '$',\n\t\t\t\twidgetClass = new RegExp( regex, 'g' ),\n\t\t\t\t// split up table class (widget id's can include dashes) - stop using match\n\t\t\t\t// otherwise only one widget gets extracted, see #1109\n\t\t\t\twidgets = ( table.className || '' ).split( ts.regex.spaces );\n\t\t\tif ( widgets.length ) {\n\t\t\t\tlen = widgets.length;\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\tif ( widgets[ indx ].match( widgetClass ) ) {\n\t\t\t\t\t\tc.widgets[ c.widgets.length ] = widgets[ indx ].replace( widgetClass, '$1' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tapplyWidgetId : function( table, id, init ) {\n\t\t\ttable = $(table)[0];\n\t\t\tvar applied, time, name,\n\t\t\t\tc = table.config,\n\t\t\t\two = c.widgetOptions,\n\t\t\t\twidget = ts.getWidgetById( id );\n\t\t\tif ( widget ) {\n\t\t\t\tname = widget.id;\n\t\t\t\tapplied = false;\n\t\t\t\t// add widget name to option list so it gets reapplied after sorting, filtering, etc\n\t\t\t\tif ( $.inArray( name, c.widgets ) < 0 ) {\n\t\t\t\t\tc.widgets[ c.widgets.length ] = name;\n\t\t\t\t}\n\t\t\t\tif ( c.debug ) { time = new Date(); }\n\n\t\t\t\tif ( init || !( c.widgetInit[ name ] ) ) {\n\t\t\t\t\t// set init flag first to prevent calling init more than once (e.g. pager)\n\t\t\t\t\tc.widgetInit[ name ] = true;\n\t\t\t\t\tif ( table.hasInitialized ) {\n\t\t\t\t\t\t// don't reapply widget options on tablesorter init\n\t\t\t\t\t\tts.applyWidgetOptions( table );\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof widget.init === 'function' ) {\n\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t\tif ( c.debug ) {\n\t\t\t\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Initializing ' + name + ' widget' );\n\t\t\t\t\t\t}\n\t\t\t\t\t\twidget.init( table, widget, c, wo );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !init && typeof widget.format === 'function' ) {\n\t\t\t\t\tapplied = true;\n\t\t\t\t\tif ( c.debug ) {\n\t\t\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Updating ' + name + ' widget' );\n\t\t\t\t\t}\n\t\t\t\t\twidget.format( table, c, wo, false );\n\t\t\t\t}\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tif ( applied ) {\n\t\t\t\t\t\tconsole.log( 'Completed ' + ( init ? 'initializing ' : 'applying ' ) + name + ' widget' + ts.benchmark( time ) );\n\t\t\t\t\t\tif ( console.groupEnd ) { console.groupEnd(); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tapplyWidget : function( table, init, callback ) {\n\t\t\ttable = $( table )[ 0 ]; // in case this is called externally\n\t\t\tvar indx, len, names, widget, time,\n\t\t\t\tc = table.config,\n\t\t\t\twidgets = [];\n\t\t\t// prevent numerous consecutive widget applications\n\t\t\tif ( init !== false && table.hasInitialized && ( table.isApplyingWidgets || table.isUpdating ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( c.debug ) { time = new Date(); }\n\t\t\tts.addWidgetFromClass( table );\n\t\t\t// prevent \"tablesorter-ready\" from firing multiple times in a row\n\t\t\tclearTimeout( c.timerReady );\n\t\t\tif ( c.widgets.length ) {\n\t\t\t\ttable.isApplyingWidgets = true;\n\t\t\t\t// ensure unique widget ids\n\t\t\t\tc.widgets = $.grep( c.widgets, function( val, index ) {\n\t\t\t\t\treturn $.inArray( val, c.widgets ) === index;\n\t\t\t\t});\n\t\t\t\tnames = c.widgets || [];\n\t\t\t\tlen = names.length;\n\t\t\t\t// build widget array & add priority as needed\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\twidget = ts.getWidgetById( names[ indx ] );\n\t\t\t\t\tif ( widget && widget.id ) {\n\t\t\t\t\t\t// set priority to 10 if not defined\n\t\t\t\t\t\tif ( !widget.priority ) { widget.priority = 10; }\n\t\t\t\t\t\twidgets[ indx ] = widget;\n\t\t\t\t\t} else if ( c.debug ) {\n\t\t\t\t\t\tconsole.warn( '\"' + names[ indx ] + '\" widget code does not exist!' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// sort widgets by priority\n\t\t\t\twidgets.sort( function( a, b ) {\n\t\t\t\t\treturn a.priority < b.priority ? -1 : a.priority === b.priority ? 0 : 1;\n\t\t\t\t});\n\t\t\t\t// add/update selected widgets\n\t\t\t\tlen = widgets.length;\n\t\t\t\tif ( c.debug ) {\n\t\t\t\t\tconsole[ console.group ? 'group' : 'log' ]( 'Start ' + ( init ? 'initializing' : 'applying' ) + ' widgets' );\n\t\t\t\t}\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\twidget = widgets[ indx ];\n\t\t\t\t\tif ( widget && widget.id ) {\n\t\t\t\t\t\tts.applyWidgetId( table, widget.id, init );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( c.debug && console.groupEnd ) { console.groupEnd(); }\n\t\t\t\t// callback executed on init only\n\t\t\t\tif ( !init && typeof callback === 'function' ) {\n\t\t\t\t\tcallback( table );\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.timerReady = setTimeout( function() {\n\t\t\t\ttable.isApplyingWidgets = false;\n\t\t\t\t$.data( table, 'lastWidgetApplication', new Date() );\n\t\t\t\tc.$table.triggerHandler( 'tablesorter-ready' );\n\t\t\t}, 10 );\n\t\t\tif ( c.debug ) {\n\t\t\t\twidget = c.widgets.length;\n\t\t\t\tconsole.log( 'Completed ' +\n\t\t\t\t\t( init === true ? 'initializing ' : 'applying ' ) + widget +\n\t\t\t\t\t' widget' + ( widget !== 1 ? 's' : '' ) + ts.benchmark( time ) );\n\t\t\t}\n\t\t},\n\n\t\tremoveWidget : function( table, name, refreshing ) {\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tvar index, widget, indx, len,\n\t\t\t\tc = table.config;\n\t\t\t// if name === true, add all widgets from $.tablesorter.widgets\n\t\t\tif ( name === true ) {\n\t\t\t\tname = [];\n\t\t\t\tlen = ts.widgets.length;\n\t\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\t\twidget = ts.widgets[ indx ];\n\t\t\t\t\tif ( widget && widget.id ) {\n\t\t\t\t\t\tname[ name.length ] = widget.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// name can be either an array of widgets names,\n\t\t\t\t// or a space/comma separated list of widget names\n\t\t\t\tname = ( $.isArray( name ) ? name.join( ',' ) : name || '' ).toLowerCase().split( /[\\s,]+/ );\n\t\t\t}\n\t\t\tlen = name.length;\n\t\t\tfor ( index = 0; index < len; index++ ) {\n\t\t\t\twidget = ts.getWidgetById( name[ index ] );\n\t\t\t\tindx = $.inArray( name[ index ], c.widgets );\n\t\t\t\t// don't remove the widget from config.widget if refreshing\n\t\t\t\tif ( indx >= 0 && refreshing !== true ) {\n\t\t\t\t\tc.widgets.splice( indx, 1 );\n\t\t\t\t}\n\t\t\t\tif ( widget && widget.remove ) {\n\t\t\t\t\tif ( c.debug ) {\n\t\t\t\t\t\tconsole.log( ( refreshing ? 'Refreshing' : 'Removing' ) + ' \"' + name[ index ] + '\" widget' );\n\t\t\t\t\t}\n\t\t\t\t\twidget.remove( table, c, c.widgetOptions, refreshing );\n\t\t\t\t\tc.widgetInit[ name[ index ] ] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefreshWidgets : function( table, doAll, dontapply ) {\n\t\t\ttable = $( table )[ 0 ]; // see issue #243\n\t\t\tvar indx, widget,\n\t\t\t\tc = table.config,\n\t\t\t\tcurWidgets = c.widgets,\n\t\t\t\twidgets = ts.widgets,\n\t\t\t\tlen = widgets.length,\n\t\t\t\tlist = [],\n\t\t\t\tcallback = function( table ) {\n\t\t\t\t\t$( table ).triggerHandler( 'refreshComplete' );\n\t\t\t\t};\n\t\t\t// remove widgets not defined in config.widgets, unless doAll is true\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\twidget = widgets[ indx ];\n\t\t\t\tif ( widget && widget.id && ( doAll || $.inArray( widget.id, curWidgets ) < 0 ) ) {\n\t\t\t\t\tlist[ list.length ] = widget.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts.removeWidget( table, list.join( ',' ), true );\n\t\t\tif ( dontapply !== true ) {\n\t\t\t\t// call widget init if\n\t\t\t\tts.applyWidget( table, doAll || false, callback );\n\t\t\t\tif ( doAll ) {\n\t\t\t\t\t// apply widget format\n\t\t\t\t\tts.applyWidget( table, false, callback );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback( table );\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t██  ██ ██████ ██ ██     ██ ██████ ██ ██████ ▄█████\n\t\t██  ██   ██   ██ ██     ██   ██   ██ ██▄▄   ▀█▄\n\t\t██  ██   ██   ██ ██     ██   ██   ██ ██▀▀      ▀█▄\n\t\t▀████▀   ██   ██ ██████ ██   ██   ██ ██████ █████▀\n\t\t*/\n\t\tbenchmark : function( diff ) {\n\t\t\treturn ( ' ( ' + ( new Date().getTime() - diff.getTime() ) + 'ms )' );\n\t\t},\n\t\t// deprecated ts.log\n\t\tlog : function() {\n\t\t\tconsole.log( arguments );\n\t\t},\n\n\t\t// $.isEmptyObject from jQuery v1.4\n\t\tisEmptyObject : function( obj ) {\n\t\t\t/*jshint forin: false */\n\t\t\tfor ( var name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tisValueInArray : function( column, arry ) {\n\t\t\tvar indx,\n\t\t\t\tlen = arry && arry.length || 0;\n\t\t\tfor ( indx = 0; indx < len; indx++ ) {\n\t\t\t\tif ( arry[ indx ][ 0 ] === column ) {\n\t\t\t\t\treturn indx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\n\t\tformatFloat : function( str, table ) {\n\t\t\tif ( typeof str !== 'string' || str === '' ) { return str; }\n\t\t\t// allow using formatFloat without a table; defaults to US number format\n\t\t\tvar num,\n\t\t\t\tusFormat = table && table.config ? table.config.usNumberFormat !== false :\n\t\t\t\t\ttypeof table !== 'undefined' ? table : true;\n\t\t\tif ( usFormat ) {\n\t\t\t\t// US Format - 1,234,567.89 -> 1234567.89\n\t\t\t\tstr = str.replace( ts.regex.comma, '' );\n\t\t\t} else {\n\t\t\t\t// German Format = 1.234.567,89 -> 1234567.89\n\t\t\t\t// French Format = 1 234 567,89 -> 1234567.89\n\t\t\t\tstr = str.replace( ts.regex.digitNonUS, '' ).replace( ts.regex.comma, '.' );\n\t\t\t}\n\t\t\tif ( ts.regex.digitNegativeTest.test( str ) ) {\n\t\t\t\t// make (#) into a negative number -> (10) = -10\n\t\t\t\tstr = str.replace( ts.regex.digitNegativeReplace, '-$1' );\n\t\t\t}\n\t\t\tnum = parseFloat( str );\n\t\t\t// return the text instead of zero\n\t\t\treturn isNaN( num ) ? $.trim( str ) : num;\n\t\t},\n\n\t\tisDigit : function( str ) {\n\t\t\t// replace all unwanted chars and match\n\t\t\treturn isNaN( str ) ?\n\t\t\t\tts.regex.digitTest.test( str.toString().replace( ts.regex.digitReplace, '' ) ) :\n\t\t\t\tstr !== '';\n\t\t},\n\n\t\t// computeTableHeaderCellIndexes from:\n\t\t// http://www.javascripttoolbox.com/lib/table/examples.php\n\t\t// http://www.javascripttoolbox.com/temp/table_cellindex.html\n\t\tcomputeColumnIndex : function( $rows, c ) {\n\t\t\tvar i, j, k, l, cell, cells, rowIndex, rowSpan, colSpan, firstAvailCol,\n\t\t\t\t// total columns has been calculated, use it to set the matrixrow\n\t\t\t\tcolumns = c && c.columns || 0,\n\t\t\t\tmatrix = [],\n\t\t\t\tmatrixrow = new Array( columns );\n\t\t\tfor ( i = 0; i < $rows.length; i++ ) {\n\t\t\t\tcells = $rows[ i ].cells;\n\t\t\t\tfor ( j = 0; j < cells.length; j++ ) {\n\t\t\t\t\tcell = cells[ j ];\n\t\t\t\t\trowIndex = cell.parentNode.rowIndex;\n\t\t\t\t\trowSpan = cell.rowSpan || 1;\n\t\t\t\t\tcolSpan = cell.colSpan || 1;\n\t\t\t\t\tif ( typeof matrix[ rowIndex ] === 'undefined' ) {\n\t\t\t\t\t\tmatrix[ rowIndex ] = [];\n\t\t\t\t\t}\n\t\t\t\t\t// Find first available column in the first row\n\t\t\t\t\tfor ( k = 0; k < matrix[ rowIndex ].length + 1; k++ ) {\n\t\t\t\t\t\tif ( typeof matrix[ rowIndex ][ k ] === 'undefined' ) {\n\t\t\t\t\t\t\tfirstAvailCol = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// jscs:disable disallowEmptyBlocks\n\t\t\t\t\tif ( columns && cell.cellIndex === firstAvailCol ) {\n\t\t\t\t\t\t// don't to anything\n\t\t\t\t\t} else if ( cell.setAttribute ) {\n\t\t\t\t\t\t// jscs:enable disallowEmptyBlocks\n\t\t\t\t\t\t// add data-column (setAttribute = IE8+)\n\t\t\t\t\t\tcell.setAttribute( 'data-column', firstAvailCol );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// remove once we drop support for IE7 - 1/12/2016\n\t\t\t\t\t\t$( cell ).attr( 'data-column', firstAvailCol );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = rowIndex; k < rowIndex + rowSpan; k++ ) {\n\t\t\t\t\t\tif ( typeof matrix[ k ] === 'undefined' ) {\n\t\t\t\t\t\t\tmatrix[ k ] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatrixrow = matrix[ k ];\n\t\t\t\t\t\tfor ( l = firstAvailCol; l < firstAvailCol + colSpan; l++ ) {\n\t\t\t\t\t\t\tmatrixrow[ l ] = 'x';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matrixrow.length;\n\t\t},\n\n\t\t// automatically add a colgroup with col elements set to a percentage width\n\t\tfixColumnWidth : function( table ) {\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tvar overallWidth, percent, $tbodies, len, index,\n\t\t\t\tc = table.config,\n\t\t\t\t$colgroup = c.$table.children( 'colgroup' );\n\t\t\t// remove plugin-added colgroup, in case we need to refresh the widths\n\t\t\tif ( $colgroup.length && $colgroup.hasClass( ts.css.colgroup ) ) {\n\t\t\t\t$colgroup.remove();\n\t\t\t}\n\t\t\tif ( c.widthFixed && c.$table.children( 'colgroup' ).length === 0 ) {\n\t\t\t\t$colgroup = $( '<colgroup class=\"' + ts.css.colgroup + '\">' );\n\t\t\t\toverallWidth = c.$table.width();\n\t\t\t\t// only add col for visible columns - fixes #371\n\t\t\t\t$tbodies = c.$tbodies.find( 'tr:first' ).children( ':visible' );\n\t\t\t\tlen = $tbodies.length;\n\t\t\t\tfor ( index = 0; index < len; index++ ) {\n\t\t\t\t\tpercent = parseInt( ( $tbodies.eq( index ).width() / overallWidth ) * 1000, 10 ) / 10 + '%';\n\t\t\t\t\t$colgroup.append( $( '<col>' ).css( 'width', percent ) );\n\t\t\t\t}\n\t\t\t\tc.$table.prepend( $colgroup );\n\t\t\t}\n\t\t},\n\n\t\t// get sorter, string, empty, etc options for each column from\n\t\t// jQuery data, metadata, header option or header class name ('sorter-false')\n\t\t// priority = jQuery data > meta > headers option > header class name\n\t\tgetData : function( header, configHeader, key ) {\n\t\t\tvar meta, cl4ss,\n\t\t\t\tval = '',\n\t\t\t\t$header = $( header );\n\t\t\tif ( !$header.length ) { return ''; }\n\t\t\tmeta = $.metadata ? $header.metadata() : false;\n\t\t\tcl4ss = ' ' + ( $header.attr( 'class' ) || '' );\n\t\t\tif ( typeof $header.data( key ) !== 'undefined' ||\n\t\t\t\ttypeof $header.data( key.toLowerCase() ) !== 'undefined' ) {\n\t\t\t\t// 'data-lockedOrder' is assigned to 'lockedorder'; but 'data-locked-order' is assigned to 'lockedOrder'\n\t\t\t\t// 'data-sort-initial-order' is assigned to 'sortInitialOrder'\n\t\t\t\tval += $header.data( key ) || $header.data( key.toLowerCase() );\n\t\t\t} else if ( meta && typeof meta[ key ] !== 'undefined' ) {\n\t\t\t\tval += meta[ key ];\n\t\t\t} else if ( configHeader && typeof configHeader[ key ] !== 'undefined' ) {\n\t\t\t\tval += configHeader[ key ];\n\t\t\t} else if ( cl4ss !== ' ' && cl4ss.match( ' ' + key + '-' ) ) {\n\t\t\t\t// include sorter class name 'sorter-text', etc; now works with 'sorter-my-custom-parser'\n\t\t\t\tval = cl4ss.match( new RegExp( '\\\\s' + key + '-([\\\\w-]+)' ) )[ 1 ] || '';\n\t\t\t}\n\t\t\treturn $.trim( val );\n\t\t},\n\n\t\tgetColumnData : function( table, obj, indx, getCell, $headers ) {\n\t\t\tif ( typeof obj === 'undefined' || obj === null ) { return; }\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tvar $header, key,\n\t\t\t\tc = table.config,\n\t\t\t\t$cells = ( $headers || c.$headers ),\n\t\t\t\t// c.$headerIndexed is not defined initially\n\t\t\t\t$cell = c.$headerIndexed && c.$headerIndexed[ indx ] ||\n\t\t\t\t\t$cells.filter( '[data-column=\"' + indx + '\"]:last' );\n\t\t\tif ( obj[ indx ] ) {\n\t\t\t\treturn getCell ? obj[ indx ] : obj[ $cells.index( $cell ) ];\n\t\t\t}\n\t\t\tfor ( key in obj ) {\n\t\t\t\tif ( typeof key === 'string' ) {\n\t\t\t\t\t$header = $cell\n\t\t\t\t\t\t// header cell with class/id\n\t\t\t\t\t\t.filter( key )\n\t\t\t\t\t\t// find elements within the header cell with cell/id\n\t\t\t\t\t\t.add( $cell.find( key ) );\n\t\t\t\t\tif ( $header.length ) {\n\t\t\t\t\t\treturn obj[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\n\t\t// *** Process table ***\n\t\t// add processing indicator\n\t\tisProcessing : function( $table, toggle, $headers ) {\n\t\t\t$table = $( $table );\n\t\t\tvar c = $table[ 0 ].config,\n\t\t\t\t// default to all headers\n\t\t\t\t$header = $headers || $table.find( '.' + ts.css.header );\n\t\t\tif ( toggle ) {\n\t\t\t\t// don't use sortList if custom $headers used\n\t\t\t\tif ( typeof $headers !== 'undefined' && c.sortList.length > 0 ) {\n\t\t\t\t\t// get headers from the sortList\n\t\t\t\t\t$header = $header.filter( function() {\n\t\t\t\t\t\t// get data-column from attr to keep compatibility with jQuery 1.2.6\n\t\t\t\t\t\treturn this.sortDisabled ?\n\t\t\t\t\t\t\tfalse :\n\t\t\t\t\t\t\tts.isValueInArray( parseFloat( $( this ).attr( 'data-column' ) ), c.sortList ) >= 0;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t$table.add( $header ).addClass( ts.css.processing + ' ' + c.cssProcessing );\n\t\t\t} else {\n\t\t\t\t$table.add( $header ).removeClass( ts.css.processing + ' ' + c.cssProcessing );\n\t\t\t}\n\t\t},\n\n\t\t// detach tbody but save the position\n\t\t// don't use tbody because there are portions that look for a tbody index (updateCell)\n\t\tprocessTbody : function( table, $tb, getIt ) {\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tif ( getIt ) {\n\t\t\t\ttable.isProcessing = true;\n\t\t\t\t$tb.before( '<colgroup class=\"tablesorter-savemyplace\"/>' );\n\t\t\t\treturn $.fn.detach ? $tb.detach() : $tb.remove();\n\t\t\t}\n\t\t\tvar holdr = $( table ).find( 'colgroup.tablesorter-savemyplace' );\n\t\t\t$tb.insertAfter( holdr );\n\t\t\tholdr.remove();\n\t\t\ttable.isProcessing = false;\n\t\t},\n\n\t\tclearTableBody : function( table ) {\n\t\t\t$( table )[ 0 ].config.$tbodies.children().detach();\n\t\t},\n\n\t\t// used when replacing accented characters during sorting\n\t\tcharacterEquivalents : {\n\t\t\t'a' : '\\u00e1\\u00e0\\u00e2\\u00e3\\u00e4\\u0105\\u00e5', // áàâãäąå\n\t\t\t'A' : '\\u00c1\\u00c0\\u00c2\\u00c3\\u00c4\\u0104\\u00c5', // ÁÀÂÃÄĄÅ\n\t\t\t'c' : '\\u00e7\\u0107\\u010d', // çćč\n\t\t\t'C' : '\\u00c7\\u0106\\u010c', // ÇĆČ\n\t\t\t'e' : '\\u00e9\\u00e8\\u00ea\\u00eb\\u011b\\u0119', // éèêëěę\n\t\t\t'E' : '\\u00c9\\u00c8\\u00ca\\u00cb\\u011a\\u0118', // ÉÈÊËĚĘ\n\t\t\t'i' : '\\u00ed\\u00ec\\u0130\\u00ee\\u00ef\\u0131', // íìİîïı\n\t\t\t'I' : '\\u00cd\\u00cc\\u0130\\u00ce\\u00cf', // ÍÌİÎÏ\n\t\t\t'o' : '\\u00f3\\u00f2\\u00f4\\u00f5\\u00f6\\u014d', // óòôõöō\n\t\t\t'O' : '\\u00d3\\u00d2\\u00d4\\u00d5\\u00d6\\u014c', // ÓÒÔÕÖŌ\n\t\t\t'ss': '\\u00df', // ß (s sharp)\n\t\t\t'SS': '\\u1e9e', // ẞ (Capital sharp s)\n\t\t\t'u' : '\\u00fa\\u00f9\\u00fb\\u00fc\\u016f', // úùûüů\n\t\t\t'U' : '\\u00da\\u00d9\\u00db\\u00dc\\u016e' // ÚÙÛÜŮ\n\t\t},\n\n\t\treplaceAccents : function( str ) {\n\t\t\tvar chr,\n\t\t\t\tacc = '[',\n\t\t\t\teq = ts.characterEquivalents;\n\t\t\tif ( !ts.characterRegex ) {\n\t\t\t\tts.characterRegexArray = {};\n\t\t\t\tfor ( chr in eq ) {\n\t\t\t\t\tif ( typeof chr === 'string' ) {\n\t\t\t\t\t\tacc += eq[ chr ];\n\t\t\t\t\t\tts.characterRegexArray[ chr ] = new RegExp( '[' + eq[ chr ] + ']', 'g' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tts.characterRegex = new RegExp( acc + ']' );\n\t\t\t}\n\t\t\tif ( ts.characterRegex.test( str ) ) {\n\t\t\t\tfor ( chr in eq ) {\n\t\t\t\t\tif ( typeof chr === 'string' ) {\n\t\t\t\t\t\tstr = str.replace( ts.characterRegexArray[ chr ], chr );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t},\n\n\t\t// restore headers\n\t\trestoreHeaders : function( table ) {\n\t\t\tvar index, $cell,\n\t\t\t\tc = $( table )[ 0 ].config,\n\t\t\t\t$headers = c.$table.find( c.selectorHeaders ),\n\t\t\t\tlen = $headers.length;\n\t\t\t// don't use c.$headers here in case header cells were swapped\n\t\t\tfor ( index = 0; index < len; index++ ) {\n\t\t\t\t$cell = $headers.eq( index );\n\t\t\t\t// only restore header cells if it is wrapped\n\t\t\t\t// because this is also used by the updateAll method\n\t\t\t\tif ( $cell.find( '.' + ts.css.headerIn ).length ) {\n\t\t\t\t\t$cell.html( c.headerContent[ index ] );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdestroy : function( table, removeClasses, callback ) {\n\t\t\ttable = $( table )[ 0 ];\n\t\t\tif ( !table.hasInitialized ) { return; }\n\t\t\t// remove all widgets\n\t\t\tts.removeWidget( table, true, false );\n\t\t\tvar events,\n\t\t\t\t$t = $( table ),\n\t\t\t\tc = table.config,\n\t\t\t\tdebug = c.debug,\n\t\t\t\t$h = $t.find( 'thead:first' ),\n\t\t\t\t$r = $h.find( 'tr.' + ts.css.headerRow ).removeClass( ts.css.headerRow + ' ' + c.cssHeaderRow ),\n\t\t\t\t$f = $t.find( 'tfoot:first > tr' ).children( 'th, td' );\n\t\t\tif ( removeClasses === false && $.inArray( 'uitheme', c.widgets ) >= 0 ) {\n\t\t\t\t// reapply uitheme classes, in case we want to maintain appearance\n\t\t\t\t$t.triggerHandler( 'applyWidgetId', [ 'uitheme' ] );\n\t\t\t\t$t.triggerHandler( 'applyWidgetId', [ 'zebra' ] );\n\t\t\t}\n\t\t\t// remove widget added rows, just in case\n\t\t\t$h.find( 'tr' ).not( $r ).remove();\n\t\t\t// disable tablesorter - not using .unbind( namespace ) because namespacing was\n\t\t\t// added in jQuery v1.4.3 - see http://api.jquery.com/event.namespace/\n\t\t\tevents = 'sortReset update updateRows updateAll updateHeaders updateCell addRows updateComplete sorton ' +\n\t\t\t\t'appendCache updateCache applyWidgetId applyWidgets refreshWidgets removeWidget destroy mouseup mouseleave ' +\n\t\t\t\t'keypress sortBegin sortEnd resetToLoadState '.split( ' ' )\n\t\t\t\t.join( c.namespace + ' ' );\n\t\t\t$t\n\t\t\t\t.removeData( 'tablesorter' )\n\t\t\t\t.unbind( events.replace( ts.regex.spaces, ' ' ) );\n\t\t\tc.$headers\n\t\t\t\t.add( $f )\n\t\t\t\t.removeClass( [ ts.css.header, c.cssHeader, c.cssAsc, c.cssDesc, ts.css.sortAsc, ts.css.sortDesc, ts.css.sortNone ].join( ' ' ) )\n\t\t\t\t.removeAttr( 'data-column' )\n\t\t\t\t.removeAttr( 'aria-label' )\n\t\t\t\t.attr( 'aria-disabled', 'true' );\n\t\t\t$r\n\t\t\t\t.find( c.selectorSort )\n\t\t\t\t.unbind( ( 'mousedown mouseup keypress '.split( ' ' ).join( c.namespace + ' ' ) ).replace( ts.regex.spaces, ' ' ) );\n\t\t\tts.restoreHeaders( table );\n\t\t\t$t.toggleClass( ts.css.table + ' ' + c.tableClass + ' tablesorter-' + c.theme, removeClasses === false );\n\t\t\t// clear flag in case the plugin is initialized again\n\t\t\ttable.hasInitialized = false;\n\t\t\tdelete table.config.cache;\n\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\tcallback( table );\n\t\t\t}\n\t\t\tif ( debug ) {\n\t\t\t\tconsole.log( 'tablesorter has been removed' );\n\t\t\t}\n\t\t}\n\n\t};\n\n\t$.fn.tablesorter = function( settings ) {\n\t\treturn this.each( function() {\n\t\t\tvar table = this,\n\t\t\t// merge & extend config options\n\t\t\tc = $.extend( true, {}, ts.defaults, settings, ts.instanceMethods );\n\t\t\t// save initial settings\n\t\t\tc.originalSettings = settings;\n\t\t\t// create a table from data (build table widget)\n\t\t\tif ( !table.hasInitialized && ts.buildTable && this.nodeName !== 'TABLE' ) {\n\t\t\t\t// return the table (in case the original target is the table's container)\n\t\t\t\tts.buildTable( table, c );\n\t\t\t} else {\n\t\t\t\tts.setup( table, c );\n\t\t\t}\n\t\t});\n\t};\n\n\t// set up debug logs\n\tif ( !( window.console && window.console.log ) ) {\n\t\t// access $.tablesorter.logs for browsers that don't have a console...\n\t\tts.logs = [];\n\t\t/*jshint -W020 */\n\t\tconsole = {};\n\t\tconsole.log = console.warn = console.error = console.table = function() {\n\t\t\tvar arg = arguments.length > 1 ? arguments : arguments[0];\n\t\t\tts.logs[ ts.logs.length ] = { date: Date.now(), log: arg };\n\t\t};\n\t}\n\n\t// add default parsers\n\tts.addParser({\n\t\tid : 'no-parser',\n\t\tis : function() {\n\t\t\treturn false;\n\t\t},\n\t\tformat : function() {\n\t\t\treturn '';\n\t\t},\n\t\ttype : 'text'\n\t});\n\n\tts.addParser({\n\t\tid : 'text',\n\t\tis : function() {\n\t\t\treturn true;\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\tvar c = table.config;\n\t\t\tif ( str ) {\n\t\t\t\tstr = $.trim( c.ignoreCase ? str.toLocaleLowerCase() : str );\n\t\t\t\tstr = c.sortLocaleCompare ? ts.replaceAccents( str ) : str;\n\t\t\t}\n\t\t\treturn str;\n\t\t},\n\t\ttype : 'text'\n\t});\n\n\tts.regex.nondigit = /[^\\w,. \\-()]/g;\n\tts.addParser({\n\t\tid : 'digit',\n\t\tis : function( str ) {\n\t\t\treturn ts.isDigit( str );\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\tvar num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );\n\t\t\treturn str && typeof num === 'number' ? num :\n\t\t\t\tstr ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\tts.regex.currencyReplace = /[+\\-,. ]/g;\n\tts.regex.currencyTest = /^\\(?\\d+[\\u00a3$\\u20ac\\u00a4\\u00a5\\u00a2?.]|[\\u00a3$\\u20ac\\u00a4\\u00a5\\u00a2?.]\\d+\\)?$/;\n\tts.addParser({\n\t\tid : 'currency',\n\t\tis : function( str ) {\n\t\t\tstr = ( str || '' ).replace( ts.regex.currencyReplace, '' );\n\t\t\t// test for £$€¤¥¢\n\t\t\treturn ts.regex.currencyTest.test( str );\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\tvar num = ts.formatFloat( ( str || '' ).replace( ts.regex.nondigit, '' ), table );\n\t\t\treturn str && typeof num === 'number' ? num :\n\t\t\t\tstr ? $.trim( str && table.config.ignoreCase ? str.toLocaleLowerCase() : str ) : str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\t// too many protocols to add them all https://en.wikipedia.org/wiki/URI_scheme\n\t// now, this regex can be updated before initialization\n\tts.regex.urlProtocolTest =   /^(https?|ftp|file):\\/\\//;\n\tts.regex.urlProtocolReplace = /(https?|ftp|file):\\/\\//;\n\tts.addParser({\n\t\tid : 'url',\n\t\tis : function( str ) {\n\t\t\treturn ts.regex.urlProtocolTest.test( str );\n\t\t},\n\t\tformat : function( str ) {\n\t\t\treturn str ? $.trim( str.replace( ts.regex.urlProtocolReplace, '' ) ) : str;\n\t\t},\n\t\tparsed : true, // filter widget flag\n\t\ttype : 'text'\n\t});\n\n\tts.regex.dash = /-/g;\n\tts.regex.isoDate = /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}/;\n\tts.addParser({\n\t\tid : 'isoDate',\n\t\tis : function( str ) {\n\t\t\treturn ts.regex.isoDate.test( str );\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\tvar date = str ? new Date( str.replace( ts.regex.dash, '/' ) ) : str;\n\t\t\treturn date instanceof Date && isFinite( date ) ? date.getTime() : str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\tts.regex.percent = /%/g;\n\tts.regex.percentTest = /(\\d\\s*?%|%\\s*?\\d)/;\n\tts.addParser({\n\t\tid : 'percent',\n\t\tis : function( str ) {\n\t\t\treturn ts.regex.percentTest.test( str ) && str.length < 15;\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\treturn str ? ts.formatFloat( str.replace( ts.regex.percent, '' ), table ) : str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\t// added image parser to core v2.17.9\n\tts.addParser({\n\t\tid : 'image',\n\t\tis : function( str, table, node, $node ) {\n\t\t\treturn $node.find( 'img' ).length > 0;\n\t\t},\n\t\tformat : function( str, table, cell ) {\n\t\t\treturn $( cell ).find( 'img' ).attr( table.config.imgAttr || 'alt' ) || str;\n\t\t},\n\t\tparsed : true, // filter widget flag\n\t\ttype : 'text'\n\t});\n\n\tts.regex.dateReplace = /(\\S)([AP]M)$/i; // used by usLongDate & time parser\n\tts.regex.usLongDateTest1 = /^[A-Z]{3,10}\\.?\\s+\\d{1,2},?\\s+(\\d{4})(\\s+\\d{1,2}:\\d{2}(:\\d{2})?(\\s+[AP]M)?)?$/i;\n\tts.regex.usLongDateTest2 = /^\\d{1,2}\\s+[A-Z]{3,10}\\s+\\d{4}/i;\n\tts.addParser({\n\t\tid : 'usLongDate',\n\t\tis : function( str ) {\n\t\t\t// two digit years are not allowed cross-browser\n\t\t\t// Jan 01, 2013 12:34:56 PM or 01 Jan 2013\n\t\t\treturn ts.regex.usLongDateTest1.test( str ) || ts.regex.usLongDateTest2.test( str );\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\tvar date = str ? new Date( str.replace( ts.regex.dateReplace, '$1 $2' ) ) : str;\n\t\t\treturn date instanceof Date && isFinite( date ) ? date.getTime() : str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\t// testing for ##-##-#### or ####-##-##, so it's not perfect; time can be included\n\tts.regex.shortDateTest = /(^\\d{1,2}[\\/\\s]\\d{1,2}[\\/\\s]\\d{4})|(^\\d{4}[\\/\\s]\\d{1,2}[\\/\\s]\\d{1,2})/;\n\t// escaped \"-\" because JSHint in Firefox was showing it as an error\n\tts.regex.shortDateReplace = /[\\-.,]/g;\n\t// XXY covers MDY & DMY formats\n\tts.regex.shortDateXXY = /(\\d{1,2})[\\/\\s](\\d{1,2})[\\/\\s](\\d{4})/;\n\tts.regex.shortDateYMD = /(\\d{4})[\\/\\s](\\d{1,2})[\\/\\s](\\d{1,2})/;\n\tts.convertFormat = function( dateString, format ) {\n\t\tdateString = ( dateString || '' )\n\t\t\t.replace( ts.regex.spaces, ' ' )\n\t\t\t.replace( ts.regex.shortDateReplace, '/' );\n\t\tif ( format === 'mmddyyyy' ) {\n\t\t\tdateString = dateString.replace( ts.regex.shortDateXXY, '$3/$1/$2' );\n\t\t} else if ( format === 'ddmmyyyy' ) {\n\t\t\tdateString = dateString.replace( ts.regex.shortDateXXY, '$3/$2/$1' );\n\t\t} else if ( format === 'yyyymmdd' ) {\n\t\t\tdateString = dateString.replace( ts.regex.shortDateYMD, '$1/$2/$3' );\n\t\t}\n\t\tvar date = new Date( dateString );\n\t\treturn date instanceof Date && isFinite( date ) ? date.getTime() : '';\n\t};\n\n\tts.addParser({\n\t\tid : 'shortDate', // 'mmddyyyy', 'ddmmyyyy' or 'yyyymmdd'\n\t\tis : function( str ) {\n\t\t\tstr = ( str || '' ).replace( ts.regex.spaces, ' ' ).replace( ts.regex.shortDateReplace, '/' );\n\t\t\treturn ts.regex.shortDateTest.test( str );\n\t\t},\n\t\tformat : function( str, table, cell, cellIndex ) {\n\t\t\tif ( str ) {\n\t\t\t\tvar c = table.config,\n\t\t\t\t\t$header = c.$headerIndexed[ cellIndex ],\n\t\t\t\t\tformat = $header.length && $header.data( 'dateFormat' ) ||\n\t\t\t\t\t\tts.getData( $header, ts.getColumnData( table, c.headers, cellIndex ), 'dateFormat' ) ||\n\t\t\t\t\t\tc.dateFormat;\n\t\t\t\t// save format because getData can be slow...\n\t\t\t\tif ( $header.length ) {\n\t\t\t\t\t$header.data( 'dateFormat', format );\n\t\t\t\t}\n\t\t\t\treturn ts.convertFormat( str, format ) || str;\n\t\t\t}\n\t\t\treturn str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\t// match 24 hour time & 12 hours time + am/pm - see http://regexr.com/3c3tk\n\tts.regex.timeTest = /^([1-9]|1[0-2]):([0-5]\\d)(\\s[AP]M)$|^((?:[01]\\d|[2][0-4]):[0-5]\\d)$/i;\n\tts.regex.timeMatch = /([1-9]|1[0-2]):([0-5]\\d)(\\s[AP]M)|((?:[01]\\d|[2][0-4]):[0-5]\\d)/i;\n\tts.addParser({\n\t\tid : 'time',\n\t\tis : function( str ) {\n\t\t\treturn ts.regex.timeTest.test( str );\n\t\t},\n\t\tformat : function( str, table ) {\n\t\t\t// isolate time... ignore month, day and year\n\t\t\tvar temp,\n\t\t\t\ttimePart = ( str || '' ).match( ts.regex.timeMatch ),\n\t\t\t\torig = new Date( str ),\n\t\t\t\t// no time component? default to 00:00 by leaving it out, but only if str is defined\n\t\t\t\ttime = str && ( timePart !== null ? timePart[ 0 ] : '00:00 AM' ),\n\t\t\t\tdate = time ? new Date( '2000/01/01 ' + time.replace( ts.regex.dateReplace, '$1 $2' ) ) : time;\n\t\t\tif ( date instanceof Date && isFinite( date ) ) {\n\t\t\t\ttemp = orig instanceof Date && isFinite( orig ) ? orig.getTime() : 0;\n\t\t\t\t// if original string was a valid date, add it to the decimal so the column sorts in some kind of order\n\t\t\t\t// luckily new Date() ignores the decimals\n\t\t\t\treturn temp ? parseFloat( date.getTime() + '.' + orig.getTime() ) : date.getTime();\n\t\t\t}\n\t\t\treturn str;\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\tts.addParser({\n\t\tid : 'metadata',\n\t\tis : function() {\n\t\t\treturn false;\n\t\t},\n\t\tformat : function( str, table, cell ) {\n\t\t\tvar c = table.config,\n\t\t\tp = ( !c.parserMetadataName ) ? 'sortValue' : c.parserMetadataName;\n\t\t\treturn $( cell ).metadata()[ p ];\n\t\t},\n\t\ttype : 'numeric'\n\t});\n\n\t/*\n\t\t██████ ██████ █████▄ █████▄ ▄████▄\n\t\t  ▄█▀  ██▄▄   ██▄▄██ ██▄▄██ ██▄▄██\n\t\t▄█▀    ██▀▀   ██▀▀██ ██▀▀█  ██▀▀██\n\t\t██████ ██████ █████▀ ██  ██ ██  ██\n\t\t*/\n\t// add default widgets\n\tts.addWidget({\n\t\tid : 'zebra',\n\t\tpriority : 90,\n\t\tformat : function( table, c, wo ) {\n\t\t\tvar $visibleRows, $row, count, isEven, tbodyIndex, rowIndex, len,\n\t\t\t\tchild = new RegExp( c.cssChildRow, 'i' ),\n\t\t\t\t$tbodies = c.$tbodies.add( $( c.namespace + '_extra_table' ).children( 'tbody:not(.' + c.cssInfoBlock + ')' ) );\n\t\t\tfor ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ) {\n\t\t\t\t// loop through the visible rows\n\t\t\t\tcount = 0;\n\t\t\t\t$visibleRows = $tbodies.eq( tbodyIndex ).children( 'tr:visible' ).not( c.selectorRemove );\n\t\t\t\tlen = $visibleRows.length;\n\t\t\t\tfor ( rowIndex = 0; rowIndex < len; rowIndex++ ) {\n\t\t\t\t\t$row = $visibleRows.eq( rowIndex );\n\t\t\t\t\t// style child rows the same way the parent row was styled\n\t\t\t\t\tif ( !child.test( $row[ 0 ].className ) ) { count++; }\n\t\t\t\t\tisEven = ( count % 2 === 0 );\n\t\t\t\t\t$row\n\t\t\t\t\t\t.removeClass( wo.zebra[ isEven ? 1 : 0 ] )\n\t\t\t\t\t\t.addClass( wo.zebra[ isEven ? 0 : 1 ] );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tremove : function( table, c, wo, refreshing ) {\n\t\t\tif ( refreshing ) { return; }\n\t\t\tvar tbodyIndex, $tbody,\n\t\t\t\t$tbodies = c.$tbodies,\n\t\t\t\ttoRemove = ( wo.zebra || [ 'even', 'odd' ] ).join( ' ' );\n\t\t\tfor ( tbodyIndex = 0; tbodyIndex < $tbodies.length; tbodyIndex++ ){\n\t\t\t\t$tbody = ts.processTbody( table, $tbodies.eq( tbodyIndex ), true ); // remove tbody\n\t\t\t\t$tbody.children().removeClass( toRemove );\n\t\t\t\tts.processTbody( table, $tbody, false ); // restore tbody\n\t\t\t}\n\t\t}\n\t});\n\n})( jQuery );\n\nreturn $.tablesorter;\n}));\n"],"sourceRoot":"/source/"}